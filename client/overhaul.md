Murmuration Gameplay Overhaul – Design & Implementation Roadmap
Overview of New Core Gameplay
Murmuration is transforming from a sandbox of flocking birds into a multi-stage migratory survival game. The new core loop centers on guiding a flock through a long migration broken into segments, managing fatigue and hazards, and evolving the flock’s traits over generations. Players will influence (not directly control) the birds by placing beacons/signals, preserving the peaceful top-down flock view, while the birds make their own decisions[1]. Success is measured by how many birds reach the final destination of a migration. After each full migration, survivors breed to produce a new generation with inherited traits, making each subsequent migration more resilient. This document details the new gameplay design and the required changes to the current codebase, including energy/fatigue mechanics, level structure, bird attributes, hazards, genetic evolution, procedural difficulty, and UI improvements.
Migration Structure and Level Flow
Multi-Leg Journey: Each migration consists of a series of level segments from a starting point “A” to the final destination “Z”, with intermediate checkpoints “B”, “C”, “D”, etc. Each level is one leg of the journey (e.g. A→B, then B→C, and so on). A full migration (A to Z) might span several such legs. This replaces the previous single-level “contract” model[2]. The flock persists across these legs – birds that survive one level will carry on to the next with their state and stats intact (except for energy, which is refilled at each stop). The game will track the flock continuously through the migration unless the player starts a new game.
Checkpoints as Rest Stops: The end of each level (e.g. point B, C, etc.) serves as a safe roost or feeding ground where birds can rest and fully recharge their energy before the next leg. This ensures continuity: surviving birds start each new segment fresh in terms of energy (endurance) but retain any other impacts (e.g. injuries, trait improvements). If the flock reaches the final destination “Z” of the migration, that migration is considered complete and a breeding phase is triggered (described later).
Level Completion Goals: The primary goal each level is simply to get as many birds as possible from the start to the end point. Unlike the previous design which had specific targets (arrivals, cohesion, time, etc.)[3], the focus here is on maximizing survival. However, we may still enforce a minimum survival requirement to progress (for example, at least one bird must reach the next checkpoint). Time is less of a strict “limit” now and more a contributor to fatigue (distance traveled matters more, see Energy mechanics below). The player does not necessarily “fail” a level if many birds die – they will just have fewer birds continuing – but if all birds die (extinction), the migration fails and the game ends (or the player must restart that migration).
Persisting State Between Levels: We will utilize the existing genetic simulation structure to carry birds forward. The GeneticSimulation class already supports keeping a dictionary of all birds and resetting their positions for a new level without resetting the population[4][5]. After each leg, we will invoke a function (similar to reset_level()) that: - Replenishes each survivor’s energy to full (endurance recharge). - Resets birds’ position to the next leg’s start (which will be the previous leg’s end coordinates). - Removes any birds that died in the level from the active population. - Optionally, records survival stats (e.g. increment survived_levels on BirdEntity[6] to track experience).
This ensures continuity of the flock from A all the way to Z. The codebase’s current GameSimulation spawns fresh agents per level[7]; we will replace that with the persistent approach in GeneticSimulation which keeps survivors in self.birds and simply repositions them for the new segment[8].
Energy and Fatigue Mechanics
Energy Gauge: Each bird has an energy/endurance meter (0 to 100) representing its fatigue level[9][10]. Flying consumes energy, and birds must rest or eat to replenish it. Crucially, energy depletes based on distance traveled, not just time. In the current simulation, energy decrement is a flat per-tick value[11], which is time-based. We will modify this to be proportional to the bird’s movement distance or speed. For example, instead of subtracting a constant 0.05 each tick, we could subtract an amount scaled by the bird’s velocity (so flying faster or covering more ground drains energy faster). This change ensures that taking longer, winding paths (greater distance) costs more energy, encouraging efficient routing.
Fatigue and Death: If a bird’s energy falls too low, it faces exhaustion. Specifically, when only ~10% of energy remains, the bird is in critical condition. The game will communicate this visually (e.g. bird icon flashing red) and mechanically – if a bird stays below 10 energy for too long, it will collapse and die from exhaustion. (Internally, this could be implemented by increasing the base energy drain when energy < 10, or simply by the bird’s energy hitting 0 shortly thereafter, as currently any bird hitting 0 energy is marked dead[12].) The code already includes a helper Agent.is_exhausted() that returns true below 10 energy[13]; we will leverage that to trigger a death if a bird remains in exhausted state (e.g. for more than a few seconds of simulation time). In essence, 0% = death, but reaching 10% is effectively a point of no return if no food is immediately found.
Rest and Refueling: Birds can recharge energy by stopping at food sources (see next section on Food). The level design will ensure that a straight-line flight from start to finish is not possible on one full tank – birds must detour to feed at least once to make it. For instance, if a level’s distance requires ~120 energy to traverse, but birds only have 100 max, there will be a feeding spot partway. When birds reach a feeding area, their energy will replenish (we may instantly refill to 100, or simulate a slower regain). In code, we can repurpose the existing logic for “food beacons” which currently restore energy gradually when within radius[14]. However, instead of a player-placed beacon, these food sources are static level elements (discussed below). We will likely increase the refill rate compared to the current +0.5 per tick[15] so that birds can recover fully during a short stop.
Energy Carry-Over: Between levels (at major checkpoints), all surviving birds get their energy fully restored (they have effectively rested at the checkpoint). Thus every new leg starts with the flock at full endurance. This simplifies gameplay and emphasizes planning within each leg independently – the challenge is making it to the next stop. The code will handle this by resetting agent.energy = 100 for all survivors at level transition (similar to how reset_level in genetic sim resets energy based on longevity[16], which typically results in full or near-full energy for each bird).
Individual Bird Attributes and Diversity
Each bird in the flock is no longer identical; they have unique abilities and stats that influence their behavior and survivability. We introduce (or emphasize) the following key attributes for each bird:
•	Endurance – How far a bird can travel on a full energy tank. Mechanically, this might tie to energy efficiency: birds with higher endurance deplete energy more slowly[17][18]. In the code’s genetic traits, this corresponds to the energy_efficiency trait[19] (or possibly longevity as a hidden trait for fatigue resistance[20]). A high-endurance bird can fly longer without resting.
•	Obstacle Detection Range – How early the bird perceives storms or predators (hazards). This aligns with the hazard_awareness trait[21]. Birds with better awareness will start evading a storm or predator sooner, meaning they may divert around it rather than blundering into danger. In implementation, this could factor into the hazard avoidance logic: currently any bird within a hazard radius is affected[22]; we could scale the effective radius or “danger_factor” based on the bird’s awareness (e.g. a bird with high awareness might treat the hazard as if it were larger – thus responding earlier and escaping with less impact).
•	Leadership (Attraction Ability) – A measure of a bird’s natural influence on the flock. Birds with high leadership tend to fly at the front or center of formations and attract others to follow them. In gameplay, if a “leader” veers away (say to avoid a storm or head toward food), other birds are more likely to copy that movement, improving group cohesion. We will likely add a new trait for this (e.g. leadership or reuse flock_cohesion trait in a new way). Implementation might involve weighting the cohesion/alignment behavior: currently, each bird averages neighbors equally[23]; we could weight neighbors with higher leadership more strongly, effectively letting leaders tug the flock’s direction. Another approach is designating a few birds with top leadership as “temporary focal points” that others treat almost like moving beacons.
•	Speed – This is the bird’s maximum flight speed (especially under stress). All birds cruise at roughly similar speeds normally, but speed comes into play during predator chases or emergency escapes. A bird with higher speed can outrun predators when sprinting. In code, we already have a speed_factor trait per bird[24]. Additionally, the simulation caps bird speed based on energy (e.g. max speed 80 when energy > 50, else 60)[25]. We might adjust this such that individual birds’ max speed = base max * their speed_factor, and allow temporary bursts when fleeing predators.
•	Other Traits: The existing code and design documents include a few additional traits like Stress Resilience (tolerance to fear)[26] and Beacon Sensitivity (how strongly they respond to player signals)[27]. These will continue to play a role but were not explicitly mentioned by the new design prompt. We will retain them as part of the genetic makeup because they enhance the depth: e.g. stress resilience means a bird doesn’t panic as much in storms/predator attacks (less erratic fleeing), and beacon sensitivity means some birds might ignore player cues while others follow diligently. Keeping these aligns with the existing code (Agent has stress and beacon_response fields[28][29]).
Gender and Reproduction: We start each new game with 100 birds: 50 males and 50 females[30]. Gender matters only for breeding (one male + one female required per offspring). During flight, male and female birds behave the same (except any visual differences). We will visually distinguish gender (e.g. blue tint for males, pink for females[31]) so the player can see the composition of the flock. Gender balance becomes a strategic element – if too many of one gender die, breeding output will drop since unpaired survivors can’t reproduce.
Stat Variability: All these traits vary slightly per bird. In generation 0 (the starting flock), traits will be randomly distributed in a reasonable range[32]. For example, one bird might have 60% hazard awareness, another 45%, etc. Visual indicators like size could reflect some traits (the existing design mentions size variation[33], which is implemented as size_factor affecting sprite scale). The differences are subtle but meaningful – some birds will naturally excel at long distance (high endurance), others at guiding the flock (leadership), etc. This creates emergent gameplay where, for instance, a very aware bird might dodge a storm early and survive where others die, or a fast bird might be the sole escapee from a falcon attack.
Environmental Obstacles: Storms and Predators
The migratory journey is fraught with dangers that the player must help the flock navigate. We focus on two main obstacle types: storms and predators. (Other hazard types from the original design like wind fields or light pollution traps can be integrated later, but storms and predators are the key in this design.)
Storms: Storms are turbulent weather zones that the birds should avoid or quickly pass through. When birds detect a storm ahead, they will attempt to avoid it by veering off course, even if it means temporarily scattering the flock. In gameplay terms, when a bird comes within a storm’s radius, it triggers an avoidance response: birds do not just continue straight; they randomly alter direction to get out of the storm area. This can break flock cohesion as each bird might take a slightly different evasive path (we simulate “panic” or confusion in the storm). In the code, we will use the hazard handling loop to implement this: currently, for storm hazards the sim applies a push force and increases stress[34]. We’ll augment that by adding a random lateral component to velocity or by temporarily reducing the cohesion/alignment forces within the storm, causing birds to spread out chaotically.
While inside a storm, energy drains faster. This is already implemented: being in a storm hazard applies a massive energy loss up to 3.0 units per tick[35][36], on top of normal fatigue. We will retain and calibrate this. The idea is that flying through a storm is extremely taxing – a bird’s stamina will plummet, meaning if they don’t exit quickly, they could die of exhaustion mid-storm. If a storm is particularly severe, there’s even a chance of instant death events (like lightning strikes); the current code simulates this with a small random chance of a bird being struck and killed[37]. We can keep such rare events to heighten the tension.
Storms in a level can be moving (e.g. drifting slowly across the map) or static. A moving storm makes the avoidance more dynamic – e.g. a storm front might sweep across the birds’ intended path, and the flock needs to detour around it. We will specify movement vectors for storms in level data (the code already sets a direction on storm hazards[38]). The simulation can update the storm’s center each tick by its velocity. We need to implement moving hazard positions over time (currently hazards are mostly stationary fields; we might create a small update in each simulation step to shift storm coordinates by hazard['direction'] * speed). This ensures storms are not trivial stationary obstacles and can catch the flock if not planned around.
Predators: Predators (e.g. hawks or falcons) are singular threats that chase and attack the birds. In a level, a predator might appear in a certain zone or randomly along the route. When the flock comes near a predator, the predator will single out birds and pursue them. The key dynamic is a chase of limited duration: a predator can fly fast to catch prey, but only for a short sprint (predators have their own stamina). If a bird can evade that initial burst – for example, by outmaneuvering or outlasting the predator’s sprint – the predator will tire and give up, letting the bird survive.
In practical terms, when birds enter a predator’s range, some will get caught and killed, but not all – usually the slower or weaker ones. The current simulation logic for predator hazards already does the following: it pushes birds away (simulating an escape maneuver)[39], increases their stress (panic)[40], and has a random chance to kill birds that get very close (within 50 units)[41]. There’s also the concept of an “alpha” predator with instant kill chance if extremely close[42]. We will build on this by incorporating the predator pursuit time. We can introduce a timer or state in the predator hazard: e.g. once a bird comes within range, mark that predator as “engaged” for, say, 5 seconds during which it can kill birds (via the random checks each tick). After 5 seconds, we assume the predator gets tired or loses the flock and stops killing new birds (maybe it flies off or perches). This means if the flock can keep fleeing (or the player can use a distraction beacon, etc.) and avoid that predator for a short time, any surviving birds after that window are safe from that particular predator. Essentially the predator hazard might “deactivate” or greatly reduce its danger factor after its active phase.
We could implement this by giving predator hazards a chase_timer. Each simulation tick, if the predator has detected the flock (birds in range), decrement the timer and apply the usual effects. Once timer hits zero, set hazard['danger'] to a much lower value or remove the hazard. This models the predator slowing down. Additionally, we might allow the fastest birds to survive: since our birds have varying speed traits, those with higher speed_factor will be more likely to outrun the predator’s danger zone before getting caught. This is implicitly handled by the random kill chance scaled by distance and “danger” value[43], but we can make it explicit: e.g., give predators a top speed value (maybe as part of hazard data), and if a bird’s speed exceeds that after some time, the bird escapes. The simulation already limits bird speed by energy[25] – perhaps during a predator chase, we override to allow birds to push toward their max potential (e.g., temporarily allow max_speed = 100 for those fleeing, using their speed_factor). This way, a bird with speed_factor 1.1 might outrun a predator of speed_factor ~1.0, whereas a slow bird gets caught.
Multiple Predators and Frequency: As migrations progress, the number and aggressiveness of predators will increase (see Procedural Difficulty). Early levels might have a single predator encounter which is avoidable, whereas later ones might throw multiple predators in sequence or “gauntlets” (e.g., a level called Falcon Corridor originally[44]). The system for predator hazards should support multiple predator entities each with their own positions and chase behaviors. We may reuse the sim.hazards.predators module (if any exists) or define predator hazard entries in level JSON with properties like position, danger, movement speed, etc. The code already spawns a default predator hazard with attributes like danger and speed[45]. We will extend that: for example, danger could correlate with how lethal it is (chance to kill if in range), and speed might correlate with how fast it moves or how large the chase radius is.
Summary: Storms encourage the player to route around or through quickly, at the cost of energy, while predators force momentary panic and culling of the flock, especially targeting the weak. Both obstacles are heavily influenced by bird traits: - Birds with high hazard awareness detect storms/predators earlier and start avoiding sooner, likely reducing losses[46]. - Birds with high stress resilience handle the chaos better – e.g., they might not scatter as far in storms or recover quicker from predator panic. - Fast birds can escape predators; cohesive birds (or those following a leader) might stick together through a storm and reform faster after. We will ensure these links exist in code (e.g., integrate hazard_detection trait by scaling the effective hazard radius, and stress_resilience by reducing added stress per tick[40] for those birds).
Player Beacons and Guidance Mechanics
The player’s role remains indirect control: you cannot steer birds individually, but you place signals (beacons) to influence their movement[47]. The new design refines what the player can and cannot do: - Beacons Steer, Not Spawn Resources: In the prior prototype, players had beacon types including a “Food” beacon that could presumably create food sources, and maybe others like “Light” or “Sound”[48]. We are removing the ability for players to create food on the fly – food is now part of level design, not a deployable. The player’s beacons will be used purely to attract or repel the flock in certain directions. For example, the player might place a Light Beacon to draw the flock toward a safe area or a Sound/Cohesion Beacon to tighten their formation. The exact beacon types available might be simplified, focusing on directional influence. - Guiding to Food: Since food/rest stops are fixed in each level, the player’s main challenge is to guide the flock to those stops. This can be done by placing a beacon near the location of the food to ensure the birds notice and go there. The flock’s natural foraging behavior plus beacon influence should lead them to it. For instance, if a food site is slightly off the direct line to the destination, the player should drop a beacon on or just beyond the food site so that birds veer toward it, refuel, then continue. In essence, the beacon system becomes a way to “steer” the flock’s path through waypoints the player deems important. - Limited Beacon Budget: We will maintain a limited number of beacons per level (e.g. 3-5) to prevent spamming[49]. This means the player must place them strategically – likely at least one to guide to each food stop, and possibly one to avoid a hazard. Unused beacons might carry over if multiple seasons or attempts are allowed, but since our structure is deterministic segments, we can simply allow the player to pause at the planning stage of each level and allocate beacons anew (similar to the original “Planning (place pre-season signals)” step[50]). - Beacon Effects: The types of beacons in the original design included Light (attract at night), Sound (increase cohesion), Food Scent (draw birds to food, consuming a stock), and Wind Lure[48]. We will simplify to a few core ones: - Attraction Beacon – a general-purpose beacon (could be represented as a light or sound) that attracts nearby birds within a radius toward it[14]. This is used to lead the flock to a point. (In code, this could use the existing mechanics of the light beacon or the food beacon minus the energy gain – essentially an attractive force). - Repellent or Avoidance Beacon – possibly a “distress call” or similar that could nudge birds away from a location (useful to divert them from a predator or storm). We might or might not include this depending on complexity; primarily, player will be guiding towards safe areas rather than explicitly steering away from danger (since often guiding toward an alternate route inherently avoids the danger). - We will remove the Food beacon from the player’s toolbox, since food is not player-spawned now. The Wind or Thermal beacon might not be needed either, as we aren’t emphasizing wind in this phase. - Beacon Half-Life: Beacons don’t last forever. They will remain active for a certain duration (e.g., a day or so in game time)[51]. In practice, since each level is fairly short (perhaps a few minutes of real time), a beacon could simply last the entire level or most of it, fading as the flock nears the destination. We retain the concept that you can’t just drop infinite permanent signals – they decay, forcing timely placement. - Usage during Level: The player can drop beacons during the flight in real-time if needed (e.g., a predator appears from the bottom of the screen – the player might quickly place a beacon to one side to swerve the flock away). This interactive element keeps the player engaged in each segment, observing and reacting (“watch to win” design pillar[52]). We will ensure the UI allows beacon placement and removal fluidly (the existing UI spec already has left panel for beacon slots and drag-and-drop placement[53] and click to remove).
Implementation in Code: The GameSimulation class currently tracks self.beacons and applies their effects each tick[54]. We will: - Remove references to beacon type 'food' from the UI and prevent players from placing those. Instead, food sites are handled separately (see below). - Possibly remove or repurpose 'shelter' and 'thermal' beacon types[14] if they aren’t needed in new design. (Shelter was reducing stress and slowing birds, thermal gave energy boost; these were more specialized. We may drop them initially to focus on core mechanics). - Continue using 'light' or 'sound' beacon logic if present (not explicitly in the snippet but presumably similar) for attraction. - Pre-placed Food: At level initialization, spawn environmental food objects. One straightforward way: use the beacon mechanism but as an immovable beacon that the player didn’t place. For example, we could define in level JSON a list of food_sites with x,y and radius. The simulation can load these and internally treat them like a beacon that gives energy. In fact, leveraging the existing code: currently, a beacon of type 'food' adds energy to nearby birds[55] – we could spawn a beacon of type 'food' at each food site at start, but mark it as not counting against the budget and not removable by player. This way, as birds come into that radius, they automatically regain energy. We just need to ensure these beacons don’t expire too quickly (perhaps give them a very long half-life or simply refresh them each level).
Alternatively, we implement food sites as a new kind of stationary object and handle them in the simulation loop separately from beacons/hazards. For instance, after processing hazards, we can check if a bird is within a certain radius of a food site, then increase its energy. Either approach is fine; using beacon logic is quick since the effect is already coded (see if beacon['type'] == 'food': agent.energy = min(100, agent.energy+0.5)[55]). We will just manage the creation of those beacons through level design rather than user input.
In summary, the player’s job is to plan a route for each leg by placing a few beacons so that the flock will hit the necessary rest stops and dodge major hazards. They remain in an advisory role, influencing but not directing each bird. This keeps with the “influence > control” philosophy[56] and makes the game about strategy and observation rather than twitch reflexes.
Genetic Evolution Between Migrations
Once a migration (all its levels from A to Z) is completed, the game enters a breeding phase to create the next generation of birds for the subsequent migration (which will likely be more challenging). We preserve the idea that knowledge/traits carry over across runs[52], but in a biological sense rather than the previous ML policy sense. Here’s how it works:
Survivors Breed: All birds that survived the entire migration (i.e. they are alive upon reaching point Z) will contribute to the gene pool. We will form breeding pairs from the survivors – specifically, one male and one female per pair (if there’s an odd bird out of one gender, that bird cannot reproduce). Each pair produces exactly one offspring[57]. This offspring will form part of the next generation. Importantly, the parents themselves remain in the population into the next generation as long as they survived (we don’t assume they die after breeding, though we could impose an age limit if desired). So the new flock for the next migration will consist of all the survivors (the parents) plus all the new offspring. For example, if 40 birds (20♂, 20♀) survived, we can get up to 20 offspring, resulting in a new flock of ~60 birds. If a large portion survived (say 80 birds), we get 40 offspring (one per pair) making 120 total; in that case we might cap the population or have some birds “retire” – more on population management below.
Inheritance of Traits: Offspring inherit their traits from their parents. Rather than a simple average, we will implement a “best of both” dominant gene selection with some randomness: - For each trait (endurance, detection, leadership, speed, etc.), the child tends to inherit the higher value from either mom or dad (i.e. the better of the two)[58]. This realizes the idea of “taking the best genes of each parent.” However, to keep things from homogenizing too quickly, we add variability: - Sometimes (e.g. 30% chance) the child might get a blended middle value instead[58], or even the lower value if luck dictates, to maintain diversity. - We also introduce small mutations – a slight random ±5% to some traits[58] – ensuring that occasionally a trait can exceed both parents or introduce new variation (which is important for long-term genetic health). - Physical traits like size and base speed might blend more directly (e.g. child’s size is average of parents plus a small random tweak)[59]. - Hidden traits like fertility and longevity can be treated similar to core traits or have their own inheritance logic (the current genetic system code has detailed logic for breeding that we can reuse[60][61], but the conceptual summary stands: each trait is inherited with a bias toward the better parent’s value).
The end result is offspring that are often stronger than either parent in each respective trait (since they often take the max). Over generations, this yields a steadily improving flock – which is desirable as challenges increase. It’s essentially an accelerated natural selection: only survivors breed, and their best attributes get passed on. (This is slightly “Lamarckian” since we’re rewarding survivors by direct trait inheritance, but it serves gameplay.)
Trait Boosts from Experience: In addition to genetic inheritance, we want to reward birds for heroic deeds within their lifetime. Special accomplishments by survivors will yield a direct stat increase (which can then be passed on genetically to their offspring as well): - Any bird that acted as a leader for a significant portion of the migration (e.g. flew at the front of the flock for at least 10% of the journey time) gains a +5% bonus to its Leadership trait. This could translate to, say, if its leadership trait was 0.5, it becomes 0.55. Mechanically, we will need to track which bird(s) are at the forefront over time. We can approximate “led 10% of the time” by tracking for each bird the number of ticks it was in the front 5 or 10% of the flock by horizontal position (since we know migration direction is generally eastward, the “front” is the one with largest x-coordinate). If a bird meets the threshold, mark it as a Flock Leader in the results. - Birds that survived a storm (entered a storm hazard and made it out alive) gain +5% to their Obstacle Detection (hazard awareness) trait, reflecting that they learned to anticipate such dangers better next time. - Birds that had close calls with predators (e.g. a predator was within a very short range but they escaped) gain +5% Speed. Or simpler: any bird that survived a predator encounter (was in a predator’s radius and didn’t die) gets the speed boost, since they likely had to sprint for their lives and improved their top speed. - These improvements can be applied directly to the bird’s Genetics attributes at end of level. For instance, if a BirdEntity has genetics.speed_factor, we multiply it by 1.05 for the qualifying birds. The code already tracks some of these events: BirdEntity.close_calls could be incremented for near misses[62], and we can use that as a trigger for a speed boost if close_calls > 0. Similarly, we might track a led_ticks count to determine leadership boost. Storm survival might be inferred from how much storm energy drain or stress the bird accumulated (or a boolean flag if it was ever in a storm zone). - Note that these trait boosts not only make the survivors themselves a bit better for the next migration (if they survive to participate again), but also raise the average genes they pass to offspring. This is a slight non-genetic improvement that we allow for gameplay fairness (rewarding the player for saving certain birds). It also creates emergent narratives, e.g. “Old Red has led the flock through three migrations and is now a seasoned veteran with high leadership.”
Next Generation Flock Composition: After breeding, we have a mix of survivors (the parents) and new offspring. We plan to keep the population roughly around 100 birds for manageability (this was the starting count and seems to work for performance and design). If a lot of birds survived and thus a lot of offspring were produced, the flock could grow too large – we will enforce a cap (for example, 100 max). The breeding system in code already contemplates capping and even “retiring” older generation birds[63][64]. Our approach: - If the total survivors + offspring > 100, we may remove the excess. Priority could be given to the youngest generation (because they likely have better genes). For instance, after creating offspring, sort all birds by their generation (newborns vs older survivors) and possibly by fitness, then keep the top 100[65]. This mimics natural turnover – older birds eventually phase out. - Conversely, if very few birds survived (say only 10), we’ll still get 5 offspring, totaling 15. That’s below a healthy population. In that case, we might allow those pairs to have more than one offspring each to rebuild numbers. We saw a hint of this in the code: if survivors < 20, they let pairs produce 3 offspring each, etc.[66]. We can adopt a simpler rule: ensure the new generation has at least ~50 birds (or some minimum for a viable flock). If not, allow multiple offspring per pair or even introduce some “immigrant” birds (a bit of random new blood) to bump it up. But ideally, through balancing, complete catastrophic losses are rare if the player plays reasonably.
After breeding, we label all offspring as Generation 1 (or increment generation count), and increment survivors’ generation index if we consider each migration a generational step. However, it might be more intuitive to keep the original birds as Gen0 until they die off, with offspring as Gen1, etc., which the code’s BirdEntity supports with a generation field[67]. We will likely use the generation field to mark which migration a bird was born in. This helps in UI (differentiate generations visually) and possibly in culling old ones.
Genetic Diversity and Mutation: One thing to monitor is genetic diversity – if only a few birds survive and breed, the gene pool can narrow (inbreeding). The original plan had a diversity metric[68][69]. We won’t delve deep into that here, but to avoid trivializing the game (where eventually all birds are clones of the single “super survivor”), our mutation factor and occasional random inheritance will maintain some variance. Also, we might include a rule that if the population gets too low, offspring get extra random mutation (to simulate a “bottleneck” recovery effect). The code does something akin to this by giving more offspring when population is critically low[66] and by always adding some new random birds if under a minimum[70]. We will use those mechanisms to keep the flock genetically healthy and capable of adapting to new hazards.
In summary, between migrations the game evolves. The new generation should on average have slightly better stats (higher endurance, awareness, etc.) than the previous generation, thanks to inheritance of the best traits. The game will get harder (next section), but the flock is also improving to meet the challenge. This creates a long-term progression where the player feels a sense of improvement not through unlocking abilities but through the birds themselves becoming stronger each run.
Procedural Level Generation and Difficulty Progression
We want each migration to be a bit harder than the last, and within a single migration, each subsequent leg can also be slightly more challenging than the previous, but not in a way that feels unfair or random. To achieve this, we’ll use procedural generation with controlled rules for level layout (hazard placement, distance length, etc.), ensuring a smooth difficulty curve.
Distance and Number of Legs: Early migrations will be shorter (fewer legs from A to Z) and each leg is shorter in distance. For example, the first migration might just be A→B (a single short hop) serving as a tutorial. The next migration might be A→B→C (two legs), and so on, up to maybe 5 or 6 legs in a later migration. We can also simply treat each “World” in the original campaign as a migration – e.g. World 1 had 4 contracts, that could correspond to a migration of 4 legs[71]. The total distance to cover in a migration increases gradually. The original level table provides distances (D column) going from 40 up to 180[3]. We can use those as rough targets for final migrations in our new scheme. So Migration 1 might total ~40 distance (one leg), Migration 2 totals ~70-80 (two legs), ... Migration 5 totals ~180 (multiple legs). Each leg will be on the order of 40–60 distance units such that one food stop is needed per leg. We’ll generate the exact distance of each leg randomly within a range, making sure it’s not trivial (e.g. at least 30% of max endurance so that fatigue matters) and not impossible (within reach with one or two stops).
Placing Food Sites: For each leg, we will procedurally place 1-2 food sources (depending on leg length). The placement should feel natural – e.g. a lake or field halfway through the route. We ensure that the direct distance from start to end exceeds 100% of bird endurance, forcing a detour. However, the distance from start to the food and then to end should be possible with two 60%+ segments. Essentially, the food acts as a bridge. If multiple foods are placed, they can be along alternate paths (giving the player some strategic choice of route). We may also adjust how much energy is restored by each food site; possibly later levels might have scarcer food so birds only refill to, say, 80% instead of 100%, requiring more careful chaining of stops (this is an advanced idea; initially we assume full refuel to keep it straightforward).
Hazard Generation: The number and intensity of hazards (storms, predators) will increase with migrations: - Early Levels: Few hazards, maybe one mild storm or one predator, and largely avoidable. E.g. Migration 1 might have just a small storm off to the side that you can totally avoid by going around (teaching the concept). - Mid Game: Introduce multiple hazards. Perhaps one leg has a storm and a predator both, forcing the player to juggle avoidance (maybe take a longer path to avoid storm, which risks running low on energy if you miss the food stop, etc.). Storms might start to cover more of the direct path, requiring a larger detour or flying through with losses if unprepared. Predators might come in pairs or in sequence (e.g. one after the other, so the flock gets harassed twice). - Late Game: Hazards can combine and be more severe. Large storm systems that definitely engulf the path (the player must use the most aware birds or speed through at a cost). Predators that have higher danger (more lethal) or appear unexpectedly (perhaps random “predator bloom” events on a timer, as hinted by original design[72]). Also possibly new hazard types like storms with lightning (already coded[37]) or protected zones (areas the flock should not enter at all, akin to no-fly zones, though that might be beyond current scope).
Procedural rules: We won’t make hazards completely random; each level generation will follow rules to ensure fairness: - For each leg, define a hazard budget/difficulty score. Early legs get a low budget (maybe 1 minor hazard), later legs get higher. E.g., in code we might randomly choose hazards from a list until the budget is filled. A storm might cost X points, a predator Y points, etc. - Ensure at least one clear route remains: The algorithm should check that there is some viable path from start to finish that a clever player can find (with beacon help) where not all birds automatically die. This might involve spacing hazards or limiting overlapping ranges. It could be informal (level designer’s intuition if levels are semi-handcrafted or using seeded patterns). - Gradually ramp parameters: e.g. storm radius/strength grows in later worlds (like W4-4 had guaranteed storm line[73]), predator danger increases. We can use world number (or migration index) to scale these. For instance, Storm strength (how fast it drains energy) might start at 2 and go up to 5 by final world; Predator danger (base kill chance) might start 0.3 and go to 0.6; Number of predators from 1 to maybe 3 in a level by the end.
We can leverage some of the existing level JSON format for hazards. The code references a levels.json from which hazards are loaded if present[74][75]. We will modify or generate those JSON entries procedurally at run-time or have templates. For example, a level config might look like:
"Level3": {
  "n_agents": 100,
  "start_zone": [200, 600, 100],
  "destination_zone": [1800, 600, 150],
  "hazards": [
     {"type": "storm", "x": 1000, "y": 500, "radius": 150, "strength": 12, "direction": [0, -1]}, 
     {"type": "predator", "x": 1400, "y": 550, "radius": 100, "danger": 0.4, "speed": 5.0}
  ],
  "food_sites": [
     {"x": 1200, "y": 400, "radius": 80}
  ]
}
In this hypothetical, the storm and predator are placed such that the direct line from start to end goes through them, but notice a food site is placed perhaps off-center (y=400) which might encourage the player to take a slightly different route. We’ll create such level data on the fly or via configuration files.
Progressive Difficulty: Each new migration (generation) will start at a higher baseline difficulty. To formalize: - Migration 1 (Gen0 flock): Very forgiving. Short distance, one leg or two legs, minimal hazards, plenty of time to reach food. - Migration 2 (Gen1 flock): Increase distance and maybe add a second hazard or trick (like crosswinds or a predator). - ... - Migration N: By the final migration, distance is long and multiple legs, hazards combine (e.g. you might go through a storm then immediately face a predator while low on energy – requiring expert play and a well-bred flock).
If we align loosely with the earlier 5-world idea[76][3], we might have 5 migrations in a “campaign”. But since we have generational improvement, the game could potentially continue indefinitely (Endless mode), but the prompt seems to frame it within a campaign context. We can decide on a final migration that tests the ultimate “dynasty” of birds the player has bred.
Level Variability: Even though levels are generated, they should remain consistent once generated (no randomization on retry) to ensure the player can learn from mistakes. We might seed the generator with the migration number so that each migration’s levels are deterministic for a given playthrough scenario. This also allows adjusting difficulty if needed (we can tweak generation rules in updates).
Boids Behavior Tuning: With increased difficulty, we may need to adjust flocking behavior parameters to maintain game balance. For example, if hazards cause too much scattering, we might increase the birds’ natural tendency to regroup after (which could be done by raising cohesion weight outside of hazard zones). The original cohesion calculation is quite involved[77], but in simpler terms, we ensure that once out of danger, birds converge again so the player doesn’t have to herd stragglers individually. This keeps gameplay focused on macro signals rather than micromanaging.
All these adjustments aim for progressive challenge: each migration pushes the player to use the improved traits of their flock and their own learned skills. By the time the player reaches the hardest migration, they should have a well-honed flock (through genetics) and a deep understanding of how to use beacons and read the environment – making victory feel like a true achievement.
User Interface and Bird Visualization
To support the new gameplay, the UI will present more information about individual birds and the flock’s status, without overwhelming the player. Key improvements include:
Bird Statistics & Inspection: The player can click on any bird to view its individual stats and history. The UI will show a small panel for the selected bird with details such as: gender (♂/♀ symbol), generation (e.g. “G2”), key trait values (endurance, detection, leadership, speed, etc.), and maybe a record of how many migrations or hazards it survived. This feature is partly in place – the current game already allows clicking agents to view stats[78]; we will extend that to include the new genetic traits. For example, if the bird has a hazard awareness of 0.65, we might display “Awareness: 65%” along with a brief description (“detects danger early”). This helps players identify which birds are their “all-stars” (e.g. a bird with very high leadership might be one they pay attention to during play).
Color-Coding and Sprites: We will visually differentiate birds: - By Gender: As mentioned, males and females have tinted colors. For instance, male birds might have a blue hue, females orange/red (or any distinct palette that is colorblind-friendly). This was outlined in the genetics design[31]. The rendering engine can apply a shader or colored sprite variation per bird (the Visual Showcase indicates breed differentiation and energy/stress color coding is already implemented[79][80]). - By Generation: We want players to recognize new birds vs old survivors. A simple approach is to adjust the color brightness or add a subtle outline based on generation. For example, Gen0 (original birds) have a neutral appearance, Gen1 (first offspring) might have slightly brighter or differently tinted feathers. Another idea is adding a tiny number label or icon on the bird (though with 100 birds that might clutter). Instead, perhaps the end-of-level summary will emphasize generation differences more than the real-time view. Still, we could provide a filter or highlight if the player wants to see, say, only Gen2 birds (this might be an advanced UI toggle). - Leadership Marker: Birds with exceptionally high leadership trait or those designated as leaders through gameplay could be marked with a small halo or distinct shape. For instance, the top 1-2 natural leaders might have a slightly larger glow, indicating other birds tend to follow them. This is subtle but can cue the player into which bird is likely at the forefront of decision-making in the flock’s movement.
Flock Statistics: We will introduce a stats panel (likely in a corner of the HUD) that shows aggregate information: - Current number of birds alive, maybe split by male/female. - A “fatigue meter” showing how many birds are in high fatigue (perhaps the percentage of flock below 20% energy). - Maybe a quick icon or number of how many birds have died this level (losses), to track the toll of hazards. - If feasible, average values of key traits in the flock (e.g. average endurance, average awareness). This might be more detail than needed during play, and could instead appear in the after-action report. But it could be nice to see, for example, “Avg Speed: 1.05×” and “Avg Awareness: 0.52” to know the overall capability of the flock.
The code’s SimulationServer already packages some telemetry for the client – e.g. it sends population, arrivals, losses, cohesion, etc. in each update message[81]. We will extend this data structure to include generation counts or trait averages. The PopulationStats dataclass exists for such summary[82] and includes averages for traits and a diversity metric, which we can utilize to display in UI (perhaps under an expandable “Flock Stats” section).
End-of-Migration Results Panel: After completing each migration (reaching point Z), a detailed results screen will show the outcome and set the stage for the next generation: - Survivors Count: How many birds (and how many of each gender) made it. Possibly list a few notable survivors by name/ID (if we have naming, or at least by trait like “Highest endurance bird survived with X% energy left”). - Losses: How many perished during this migration, maybe broken down by cause (e.g. 5 lost to storms, 3 to predators, 2 to exhaustion). - New Offspring: How many hatchlings were born. We can display something like “20 pairs bred, yielding 20 offspring (Gen2)”. If possible, show a quick summary of the offspring traits (maybe an average or highlight extremes: “Offspring inherited stronger endurance from parents, avg endurance +5% over last generation”). - Trait Changes: This is a critical part to illustrate the evolution. We can present a before vs after comparison of the flock’s genetic makeup. For instance, a small table or bar chart of average trait values in Gen1 vs Gen2, highlighting increases. If our PopulationStats computed avg_hazard_awareness etc., we use that to show improvement. E.g. “Awareness: 0.50 → 0.55 average (+0.05)” indicating the flock is more aware now. The Diversity index could also be shown to reassure the player that the gene pool is still varied (or warn if it’s not). - Bird Lineage Highlights: We might include a “Hall of Fame” callout – e.g. if a particular bird has now survived 3 migrations and led the flock twice, that could be noted (“Bird #27 (F) – veteran leader, +10% leadership over two migrations”). The GENETICS_SYSTEM notes ideas like a Hall of Fame and top bloodlines[83]. We can implement a simplified version: maybe just list the top 3 birds by a fitness or contribution score, to create a narrative. - New Flock Preview: Show the composition of the new generation that will start the next migration. For example: “Next Generation: 60 birds (34 males, 26 females). Gen2: 20 new, Gen1: 40 surviving.” We can visually present the flock with color coding by generation (e.g. new offspring blinking or outlined). If feasible, an interactive family tree for a selected bird could be accessible (though that might be a stretch goal; the server does have a get_family_tree message handler[84], implying some support for lineage graphs).
This end-of-migration panel is crucial for player understanding. It celebrates the success (or failure) and prepares strategy for the future. Implementing it will mostly be on the client side (React UI), taking data from the simulation. We will ensure the server provides all needed info (list of survivors and their traits, list of offspring, etc., possibly via an extended SimulationResult or a final message type when migration ends).
Miscellaneous UI: - The primary HUD will continue to show basic info like the day/time (if we keep a time-of-day system), a minimap with fog of war, and toggles for overlays (wind, risk, etc.) as per original design[85]. We might not need the strike counter or protected area indicators from the old design, depending on if we include those fail conditions. - Controls remain the same: pause, speed control, beacon placement with mouse, etc. No direct control of birds will be introduced. - Accessibility: Different bird colors for gender should be chosen with colorblindness in mind (perhaps use symbols in UI as backup). The UI system from before already considered high-contrast modes[86] which we will maintain.
Overall, the UI should give the player clarity into the flock’s health and composition, enabling informed decisions (where to place beacons, which birds to safeguard). It also needs to provide feedback on why birds died (so the player learns to avoid that next time) and how the flock is improving (to motivate the meta-progression). With the above enhancements, the player will see their flock evolve visually and statistically from one migration to the next, fulfilling the “readable complexity” and “learning across runs” pillars[47].
Implementation Roadmap
To implement this overhaul, we will tackle it in stages. Below is a detailed roadmap linking the design elements to specific changes in the codebase and development tasks:
1.	Game Mode Refactor – Persistent Flock and Multi-Level Flow:
2.	Integrate GeneticSimulation as the core game loop: Transition from using GameSimulation (single level, disposable agents) to using GeneticSimulation (persistent agents with genetics) for the primary game mode. This involves initializing a GeneticSimulation for the campaign, which can run through multiple legs. We will use methods like reset_level() in GeneticSimulation to move to the next segment without wiping survivors[87][88]. Ensure that after each level, the simulation is not torn down; instead, call a reset to reposition birds and load new hazards.
3.	Level sequencing: Implement logic to load the next level in sequence after completing one. Possibly maintain an index of current checkpoint (e.g., A->B is level1, B->C level2, etc.). Once final level of a migration is done, trigger the breeding phase (see step 5).
4.	Data persistence: Ensure that important bird data (traits, survived_levels count, etc.) persists across level loads. The GeneticSimulation.birds dict will retain BirdEntity objects[89], so we must be careful not to re-init it each level. We may add a flag or separate mode in SimulationServer to indicate we’re in campaign mode so it doesn’t create a fresh simulation on each “load_level” message, but rather calls reset_level on the existing one.
5.	Remove old victory conditions: The prior win conditions (target_arrivals, time_limit, strikes) in GameConfig[90] become less central. We will simplify: victory for a level is reaching the checkpoint (not all birds, just at least one). Remove or ignore target_arrivals and time limits – or set them generously so they don’t enforce failure arbitrarily. The only fail condition per level should be extinction of the flock (population < 1), which is already handled[91]. We can drop the cohesion collapse or other fail states from campaign mode to focus on survival gameplay (those were more relevant to sandbox scoring).
6.	Energy & Fatigue System Updates:
7.	Distance-based energy drain: Modify the simulation step where energy is decremented each tick. In the current code, energy decays by a fixed 0.05 each tick[11]. Change this to something like:

    distance_traveled = np.linalg.norm(agent.velocity) * dt  
agent.energy = max(0, agent.energy - (distance_traveled * energy_decay_rate))
    We’ll calibrate energy_decay_rate so that a bird flying at normal cruising speed will use roughly, say, 1–2 energy units per second (tuning needed). This ties usage to actual movement distance. Birds gliding slowly or circling will consume less, whereas a bird sprinting (high velocity) to escape a predator will burn energy faster.
8.	Exhaustion death: Implement a check that if agent.is_exhausted()[13] returns true (energy < 10) for a sustained period, the bird dies. One approach: each tick that energy < 10, increment an exhaustion_time; if it exceeds some threshold (e.g. 5 seconds of game time), set agent.alive=False and log a death due to fatigue. Alternatively, we can simply rely on the fact that if no food is found, the continuing distance-based drain will reach 0 soon anyway, causing death as per existing code[12]. The nuance is to possibly make <10 a critical zone that drains faster or is irreversible. We might not need a separate mechanic if distance-based drain naturally brings it to 0, but we’ll test and adjust.
9.	Recharge at food: Implement automatic energy restoration when at a food site. The easiest way: treat food sites as beacons of type 'food'. We can update level loading to parse food_sites and for each, do something akin to:

    self.beacons.append({ 'id': 'food'+str(i), 'type': 'food', 'x': fx, 'y': fy, 'radius': fradius, 'strength': 1.0 })
    Using strength 1.0 and the existing beacon handling will give +0.5 energy per tick in radius[55]. We may increase that strength or modify the beacon handling to give a bigger boost or even instant refill when at the exact food point. Another implementation: explicitly loop through food_sites in the simulation step and do energy += some value when in range. Either way, test that birds can refill from near-empty to full by staying at the food for a short while. We might also slow birds down or cause them to circle when at a food site (simulating landing/feeding). A simple way: when a bird is in food radius and energy < 100, zero out its velocity or reduce it significantly for a few seconds (to simulate roosting) – this could be done by, say, applying a brake or using the existing “shelter beacon” mechanic which slows birds[92]. This prevents them from overshooting the food.
10.	UI feedback: Update the energy UI bar (if any) or color coding to reflect the new mechanics. Possibly color the bird sprite red when below 10% energy (the Visual Showcase mentions red for low energy[80] which might already be done). Ensure the HUD displays something like “Exhaustion imminent!” if many birds are low on energy.
11.	Beacon System Adjustments:
12.	Remove Food Beacon from player UI: Update the beacon selection so the player cannot choose a food beacon (since food is environmental now). Likely in the React UI side, remove that icon/option. Also adjust beacon budget if needed (since one type removed, maybe budget stays same but now for other types).
13.	Implement/retain useful beacons: Ensure the attraction beacon (light/sound) works. In code, a light beacon might not be explicitly coded, but we can reuse the 'food' type as a generic attractant by removing the energy gain portion. Alternatively, define a new beacon type 'attract' that just pulls birds with a certain strength (similar to how food beacon does minus the energy effect). We might reuse 'thermal' beacon's forward boost or scrap it.
14.	Beacon effect balancing: Possibly increase the radius or strength of beacons to make them more influential, since guiding birds precisely to food or around hazards may need strong signals. The design doc listed beacon radii ~150-200[48]. We can tweak those constants in code (search for usage of beacon['radius'] and beacon['strength']). For instance, ensure that if a beacon is placed slightly off the flock’s path, it reliably pulls them.
15.	Beacon decay: Keep the concept of half-life, but ensure it’s communicated to player (e.g. a timer on the beacon icon). We may use the existing half-life values from design doc or adjust. Possibly not a priority for initial implementation – beacons could last whole level initially, for simplicity, then we refine if needed for difficulty.
16.	Hazard avoidance vs Beacon: Make sure that the birds don’t blindly follow a beacon into a hazard. If a beacon’s attraction is too strong, birds might ignore their own hazard avoidance and go through a storm because the player said so. In an ideal implementation, birds weigh both – e.g., if a storm is directly on the path to the beacon, the birds’ AI should decide to detour anyway rather than suicide. This might require tuning weights: the flock’s steering algorithm (which sums migration force, beacon influence, and avoidance)[54][93] should prioritize hazard avoidance (high danger) over beacon attraction. We can increase the effect of hazard forces or reduce beacon influence when energy is high risk. This is more of an AI tuning detail, but important for emergent behavior.
17.	Bird Attributes Implementation:
18.	Expand Genetics model: Our Genetics dataclass already covers hazard_awareness, energy_efficiency, etc. We will add leadership if not already present. The GENETICS_SYSTEM.md didn’t list leadership explicitly, and the current code doesn’t have a direct leadership trait. We can define leadership: float = 0.5 in Genetics. This will require:
o	Adding it to the Genetics class definition in simulation_genetic.py (similar format as other core traits) and include it in to_dict and random initialization (maybe random between 0.4–0.6 like others).
o	Also include it in breeding logic (most likely as part of a trait group – perhaps group it with social traits). If we treat leadership as separate, we can implement inheritance: child gets one parent’s leadership with mutation, or average, etc.
o	Add corresponding field in Agent or BirdEntity if needed. Perhaps an agent doesn’t need a direct field for leadership if it’s mostly used in flocking logic; we can access a bird’s Genetics via BirdEntity when computing influence. But for performance, maybe we mirror it on Agent as we did with hazard_detection and beacon_response. So we might add agent.leadership: float and set agent.leadership = genetics.leadership when creating a bird[94].
19.	Integrate traits into simulation: Use these traits in movement and hazard logic:
o	Hazard Awareness: currently, all birds check if dist < hazard.radius uniformly[95]. We can modify this check to incorporate awareness. For example, effectively enlarge the hazard radius for high-awareness birds. Implementation: effective_radius = hazard.radius * f(awareness) where f(awareness) might be 1 + (trait - 0.5) (so 0.5 awareness = 1x radius, 1.0 awareness = 1.5x radius, 0.0 = 0.5x radius maybe). Then use effective_radius in the distance comparison for that agent. This way, an aware bird will start reacting when further out (danger_factor kicks in earlier), whereas a low-awareness bird might not react until it's very close (almost too late).
o	Leadership: incorporate into flock cohesion/alignment. Possibly modify get_neighbors or how velocity alignment is applied[23]. For instance, we can weight each neighbor’s influence by (neighbor_agent_owner.leadership * some factor) when computing the average velocity or center. Or simpler: identify if any neighbor has leadership > 0.8, then bias the cohesion target toward that bird’s position a bit more. This needs experimentation but even a simple rule like “the bird with highest leadership in the local neighborhood pulls others 10% more strongly” could be effective. We could add in the loop for cohesion: if neighbor has leadership L, treat the neighbor’s position as repeated L times or weight the sum.
o	Speed factor: Already used when creating velocity[96] and in capping max speed if energy high vs low[25]. We should ensure these formulas are consistent. Perhaps raise the max speed cap slightly and incorporate speed_factor: e.g., instead of fixed 80 or 60, do max_speed = (80 if agent.energy>50 else 60) * agent.speed_factor. That way a bird with 1.1 speed_factor might have max ~88 (so 10% faster). The code currently doesn’t multiply in speed_factor on the cap, which it should for authenticity. We will add that.
o	Stress resilience: The code increases agent.stress in storms and predator chases[97][40]. We should reduce the stress increase for high resilience birds. Implementation: when applying stress += X * danger_factor, multiply X by (1 - stress_resilience) perhaps. E.g., agent.stress += 0.1 * (1 - agent_resilience) * danger_factor. If a bird has 0.8 resilience, it only gets 20% of normal stress. We have to get each bird’s resilience trait; currently agent doesn’t store it explicitly but we can derive it from genetics if needed. Perhaps easier: store agent.stress_resist = genetics.stress_resilience during creation, similar to hazard_detection, so we have it readily in simulation loop.
o	Beacon sensitivity: Already accounted for in Agent.beacon_response[29], but we need to apply it. In the beacon loop, we can multiply the velocity influence by agent.beacon_response. For instance, when adding velocity toward beacon[55], do agent.velocity += (to_beacon/dist) * strength * dt * agent.beacon_response. That way a bird with low sensitivity might not divert fully (perhaps drifting slower toward beacon), whereas high sensitivity bird beelines. This might already be intended but not explicitly shown in snippet, so we will add it.
20.	Testing trait effects: Once integrated, test scenarios: e.g., spawn a high-awareness and low-awareness bird near a hazard and verify the high-awareness one turns earlier. Or place a beacon and see that a high beacon_response bird goes sooner than a low one. Adjust constants as needed for noticeable but balanced effects.
21.	Breeding Phase Implementation:
22.	Triggering breeding: After the final level of a migration, we need to stop the simulation (pause game time) and perform breeding. We can detect this when current_leg == total_legs and level completed (i.e., game_over or all living birds are in destination zone). The SimulationServer might receive a message or simply know when a level is last. Perhaps simpler: at level end, call a new method like GeneticSimulation.complete_migration().
23.	Use existing breed logic: The code already has GeneticSimulation.breed_population() which does much of what we want[98][99][100]. It finds survivors, pairs them, and creates offspring, handling multiple offspring in low-pop cases, capping population, etc. We will reuse a lot of this:
o	We might simplify selection (we don’t necessarily need the selective breeding by top 70% fitness as in code[101] unless we want to simulate natural selection further). The design said “exactly one per couple”, implying every surviving pair breeds regardless of fitness. To match the design prompt literally, we could ignore the fitness sorting and cutoff and just pair up as many as possible. However, the code’s approach is a bit more nuanced (to avoid weak survivors breeding if plenty of stronger ones exist). We can decide to either keep that complexity (makes the game a bit more about keeping the fittest alive) or not. A compromise: initially, breed all survivors (one offspring each pair) to align with design simplicity. If balancing becomes an issue, we can reintroduce selection.
o	Ensure one male, one female pairing. The code splits survivors by gender and pairs them up in order[102]. That works; we’ll use it. We will drop the “top performers breed multiple times” idea for now to stick to one per pair (unless population is critically low).
o	Trait inheritance: The code’s Genetics.breed() method is quite detailed with group inheritance and dominant vs blend logic[103][61]. That actually achieves the “best of both with some randomness” that we described. So we will call Genetics.breed(parent1.genetics, parent2.genetics) to get child genetics[104]. We might tweak the probabilities inside if needed to ensure it aligns with our intentions (e.g. currently 40% chance to inherit entire trait groups from one parent[105], we could adjust that). But likely it’s fine as is.
o	Add leadership to breeding: If we introduced leadership trait, we must update Genetics.breed to handle it. Possibly treat it in the 'social' group with cohesion and sensitivity, or add a new group. Or handle it individually like others with a dominant/blend approach (similar to what is done for each trait in code lines 125-148 for those not in groups).
o	Post-breeding updates: The breed code in breed_population already does: increment generation counter, create offspring via create_bird, clear and rebuild self.birds with survivors and offspring, cull or fill population to target[106][64]. We will reuse this but perhaps modify the target population logic:
o	We likely want to cap at 100 (which code sets MAX_POPULATION=100)[107] – that fits our design of ~100 size.
o	The code ensures minimum 50 by adding mutated new birds if under min (MIN_POPULATION=50)[70]. We can keep that as it prevents game over in case of mass extinction (it’s like some birds from outside join – not realistic but a gameplay grace; or we could interpret it as “some juveniles from previous season who sat out now join”, etc.).
o	The survivors’ energy and state are reset for next level in that code (they do survivor.agent.energy = full, etc.)[108]. That will naturally happen at the start of a new level anyway, but it’s fine.
o	Experience-based trait boosts: We will augment the breeding process to apply the +5% trait bonuses for special survivors before breeding. We can iterate over each survivor BirdEntity and check:
o	If bird.survived_levels >= total_legs_of_migration (meaning it survived the whole migration) – by definition in survivors list it did. But more specifically for leadership, check if we have tracked bird.led_time_fraction >= 0.1 (we need to accumulate during simulation how long each bird was a leader; perhaps add a field BirdEntity.lead_time or count and compute fraction = lead_time_ticks / total_ticks). For those birds, do bird.genetics.flock_cohesion += 0.05 or if we added a separate leadership trait, bird.genetics.leadership += 0.05. Clamp at max 1.0. Log this in a summary (so we can show in UI).
o	If bird.hazard_encounters["storm"] is True (we can set a flag if a bird went through any storm area and survived), then bird.genetics.hazard_awareness += 0.05. If storms were severe, maybe cap at some limit if done repeatedly, but likely these migrations are finite enough.
o	If bird.hazard_encounters["predator"] True (bird was targeted or in predator zone and lived), then bird.genetics.speed_factor = min(bird.genetics.speed_factor * 1.05, 1.2) or similar (ensuring not to exceed some realistic bound). We must apply these before creating offspring, so that the improved values are passed to the child. The code structure could allow this: we can modify survivors’ Genetics in place after determining survivors list and before generating offspring. The fitness_score might change slightly due to this, but that’s fine.
o	These adjustments require that we track those encounter flags during simulation. We can set up in the simulation loop:
	When a bird is inside a storm (dist < radius) mark something like bird_entity.hazard_encounters["storm"]=True.
	When in predator radius and escapes, mark "predator"=True.
	Leadership tracking: every few ticks, find which bird is furthest along the migration direction (max x) and increment a counter for it. Or track a small set of front-runners. This can be done in simulation_game or genetic_sim step easily by scanning positions.
o	Finally, incorporate these fields in the end-of-migration message so that the UI can display the achievements (e.g. “5 birds gained leadership skill” etc.).
24.	Testing breeding: Simulate a scenario (maybe unit test level) where known survivors breed and check that offspring traits make sense (no values out of range, improvements visible). Verify population count logic (no over/under-population issues).
25.	Procedural Level Generation & Content Scaling:
26.	Level generator function: Create a function that given the migration index (1-based) and leg index (if needed) produces a level config (start/dest coordinates, hazards list, food sites). This can use random but seeded for reproducibility. We can base it loosely on templates from original levels for structure.
o	For example, for migration i, decide number of legs n (maybe n = i+1 or similar, capping at 5). For each leg j, generate:
o	Distance = random in [D_min, D_max] for that migration stage. We have reference distances from design doc[3]. Possibly use those directly: migration1 ~40, migration2 ~60-90, etc.
o	Start = last leg’s destination or if first leg, fixed at A (0, some midpoint Y). Destination = (start.x + distance, some Y ± variation). We can keep Y about mid (600) with variation so that path isn’t perfectly straight – e.g. one leg could go slightly north, next south.
o	Place hazards: number of hazards = maybe round(i/2) for storms + round(i/2) for predators (so migration1 maybe 1 hazard total, migration5 maybe 5 hazards?). Specifically, if migration i has e.g. i storms and i predators over its entire span, distribute them among legs. For each hazard:
	If storm: pick a position along the route. Possibly center it near the middle of the leg to force confrontation. radius maybe 100-150 early, up to 200 late. Strength escalate by i (10 base + 2*i for example). Add direction vector if we want it to move (maybe random direction).
	If predator: position near the latter half of leg (so it catches tired birds?), or near food site (evil but interesting). Danger maybe 0.3 + 0.1i, speed maybe 5 + 1i. Possibly mark some as alpha if i large.
o	Place food: each leg should have at least one food. Place it roughly 50-60% of the way through the leg (so birds can reach it when they’ve used ~50% energy). Possibly adjust if hazards present – e.g. put food right after a storm as a relief. Or multiple food if distance is very long (migration5 might require two stops in one leg).
o	This generator can be deterministic if seeded with migration index, or we can store the generated outputs so that retries load the same hazards.
27.	Integration: When starting a migration, instead of loading from static levels.json, call this generator to create each level’s config and perhaps store it in a temporary structure (or monkey-patch into levels dict so that from_level can retrieve it[109] without needing actual file). Or directly bypass GameConfig.from_level and use our own logic to set GameConfig/GeneticSimulation parameters.
28.	Difficulty parameters: Possibly maintain a config file or constants for min/max values of hazards per migration. We can refine these after testing to ensure gradual ramp. Use debug runs to see that Migration1 is indeed easy, Migration5 indeed hard.
29.	Testing fairness: Simulate using an automated run or careful playthrough that each generated level is winnable with a decent strategy. Adjust randomness if something unfair arises (like a storm exactly covering the only food – that could kill everyone; maybe ensure food isn’t inside a storm radius by adjusting positions).
30.	Progress save: If the campaign is long, consider allowing the player to restart a migration if they fail (they’d lose that generation perhaps) or save progress after each migration. This might be beyond immediate scope, but note it.
31.	Visual and UI Updates:
32.	Rendering differences: Implement gender-based color variation. Likely in the rendering code (Phaser), when drawing an agent, check agent.gender and tint accordingly. The data already sends breed or we can send a gender flag for each agent in the state_update message. Possibly the breed field in state_update[110] was intended for genetic mode info (it’s empty in our usage, we might repurpose it or add a new field “gender”: "M"/"F"). Do similarly for generation (could encode generation number to maybe the color hue or send explicitly for UI to display as text on hover).
33.	Click for stats panel: Extend the agent click logic to show our new traits. We will create a UI component (e.g. an overlay or sidebar) that populates with the selected bird’s details. This can query the server for that bird’s full data if not already available. The server has send_family_tree and such, implying we can fetch lineage on click[84]. At minimum, we show current trait values (in percentages or bars) and possibly a mini family tree (bird’s parents and any offspring if applicable). This leverages existing genetics tracking (the server maintains family_trees and could provide it).
34.	End-of-migration screen: Develop a new UI screen that triggers on migration completion. The server can send a summary message, or the client can compile from the data it has. We might have the server send a special “migration_complete” event containing:
o	Count of survivors (with breakdown by gender and perhaps listing any special survivors).
o	Count of offspring produced.
o	A list of trait averages before vs after breeding (we can compute pre-breeding avg and post-breeding avg easily via PopulationStats[111]).
o	Names/IDs of birds that got bonuses (the ones we gave +5% leadership etc.) and what they got, so we can highlight “Bird 27 got +Leadership for leading the flock”.
o	Any “retired” birds if we remove old generation beyond lifespan (the code retires after 3 generations by default[112]). We can mention if some of the very original Gen0 finally died of old age or were retired.
35.	The UI will present this info in a clear format, using maybe charts or lists. We should also give the player a choice here like “Proceed to next migration” button, allowing a moment to digest info.
36.	HUD changes in-level: Add small indicators to birds if needed (like a crown icon on a leader bird, or a skull icon briefly over a bird that just died). And on the HUD, display number of birds remaining vs start, so player knows losses at a glance. Possibly an energy gauge visual for the whole flock (maybe an average energy or a graph of how many are in each energy range).
37.	Test UI: Ensure that performance is okay when showing stats for up to 100 birds. The current implementation only sends up to 300 agents data per tick[113] which is fine. We might extend each agent’s data to include gender and generation for easier client rendering.
38.	Testing & Balancing:
39.	Conduct several test playthroughs (or simulations) of the campaign. Use logging to verify that:
o	Energy consumption feels right (birds reach food with just a bit of energy left if guided well; if mismanaged, they run out around 10% and die as intended).
o	Hazard interactions yield some losses but not total flock wipes if handled; e.g., in a storm maybe 10-20% birds die from exhaustion or lightning if the player went through it, which might be acceptable, whereas smart avoidance could reduce that.
o	Predators kill a few birds but many escape – adjust predator danger or chase time if needed. Check that fast birds do survive more often.
o	Breeding results in noticeable trait improvements. After two migrations, see that, say, average endurance went up and indeed the flock performs better (maybe they can handle a slightly longer flight without extra food).
o	Difficulty ramps appropriately – by final migration, without those improvements the flock would have a hard time, but with them it’s manageable (still challenging).
40.	Pay attention to edge cases: what if in Migration 1 the player loses 90% of birds but 5 survive and breed? The next gen will be small (maybe repopulated to 50 by code). Is it still feasible to continue? Possibly yes, with some random new birds (mutation) injected. We might consider a soft fail state or difficulty adjustment if a flock is nearly wiped out (or just rely on repopulating to give the player another chance at cost of genetic quality).
41.	Balance beacon usage: does the player have enough beacons to reasonably guide the flock through hazards and to food? If not, consider increasing beacon budget or beacon effectiveness.
42.	Ensure performance remains good with these changes (the flock size is same, but we added some computations per agent – should be fine given numpy vectorization for many parts).
43.	Lastly, update any tutorials or in-game help to explain these new mechanics (for example, an intro tooltip: “Lead your flock from one feeding ground to the next. Place beacons to guide them. Watch their energy – if it drops too low, they’ll perish mid-flight!”).
By following this roadmap, we will replace the old sandbox/campaign mechanics with a cohesive new system focused on survival, strategic routing, and genetic progression. The codebase already has strong foundations (flocking, hazards, basic genetics) that we are expanding upon. Each step above corresponds to concrete changes (with source references) ensuring we leverage existing functionality[34][114] and add what’s missing. This transformation will deliver a compelling gameplay experience where each migration feels like a meaningful journey and each new generation of birds stands a better chance against an increasingly harsh world.
Sources: - Murmuration README – project overview[115][116]
- Murmuration Full Design v0.1 – original systems, for reference[117][118]
- Genetic Evolution System – traits and breeding rules[30][119]
- Simulation Code – energy, hazard, and beacon mechanics[34][114]
- Visual System Showcase – UI capabilities like clicking agents for stats[78][80]
 
[1] [2] [3] [44] [47] [48] [50] [51] [52] [53] [56] [68] [71] [72] [73] [76] [77] [85] [91] [117] [118] murmuration_full_game_tech_design_doc_v_0.md
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/murmuration_full_game_tech_design_doc_v_0.md
[4] [5] [6] [8] [16] [19] [20] [21] [24] [32] [59] [60] [61] [62] [63] [64] [65] [66] [67] [70] [82] [87] [88] [89] [94] [96] [98] [99] [100] [101] [102] [103] [104] [105] [106] [107] [108] [111] [112] simulation_genetic.py
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/sim/simulation_genetic.py
[7] [11] [12] [14] [15] [22] [23] [25] [34] [35] [36] [37] [38] [39] [40] [41] [42] [43] [45] [49] [54] [55] [74] [75] [90] [92] [93] [95] [97] [109] [114] simulation_game.py
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/sim/simulation_game.py
[9] [10] [13] [28] [29] agent.py
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/sim/core/agent.py
[17] [18] [26] [27] [30] [31] [33] [46] [57] [58] [69] [83] [119] GENETICS_SYSTEM.md
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/GENETICS_SYSTEM.md
[78] [79] [80] [86] VISUAL_SHOWCASE.md
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/docs/VISUAL_SHOWCASE.md
[81] [84] [110] [113] server.py
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/sim/server.py
[115] [116] README.md
https://github.com/BenPomme/murmuration/blob/032cb042d817ad4c20b73c0885beb5ec74045935/README.md

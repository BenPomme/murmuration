/**
 * Input System Integration for Murmuration Game
 * 
 * Main integration point that combines all input systems:
 * - InputManager (mouse/pointer input)
 * - MobileInputHandler (touch/gesture input) 
 * - AccessibilityManager (keyboard navigation)
 * - CameraController (camera management)
 * - InputStateManager (state management and conflict resolution)
 * - FeedbackManager (interaction feedback)
 * 
 * This file provides a unified API and example usage.
 */

import { Scene } from 'phaser';
import { InputManager, InputConfig, InputEventType, BeaconType, PulseType } from './InputManager';
import { MobileInputHandler, GestureConfig, GestureType, GestureEvent } from './MobileInputHandler';
import { AccessibilityManager, AccessibilityConfig, AccessibilityEvent } from './AccessibilityManager';
import { CameraController, CameraConfig, CameraMode } from './CameraController';
import { InputStateManager, InputStateConfig, InputContext } from './InputStateManager';
import { FeedbackManager, FeedbackConfig, FeedbackType, FeedbackIntensity } from './FeedbackManager';

export interface MurmurationInputConfig {
    // Individual system configs
    input?: Partial<InputConfig>;
    mobile?: Partial<GestureConfig>;
    accessibility?: Partial<AccessibilityConfig>;
    camera?: Partial<CameraConfig>;
    state?: Partial<InputStateConfig>;
    feedback?: Partial<FeedbackConfig>;
    
    // Global settings
    debugMode?: boolean;
    performanceMode?: boolean;
    platform?: 'desktop' | 'mobile' | 'auto';
}

export interface InputSystemCallbacks {
    onBeaconSelect?: (type: BeaconType) => void;
    onBeaconPlace?: (type: BeaconType, x: number, y: number) => void;
    onBeaconRemove?: (id: string) => void;
    onPulseActivate?: (type: PulseType) => void;
    onCameraChange?: (mode: CameraMode, x: number, y: number, zoom: number) => void;
    onGameAction?: (action: string, data: any) => void;
    onPerformanceWarning?: (warning: { type: string; data: any }) => void;
}

/**
 * Main input system coordinator that manages all input subsystems
 */
export class MurmurationInputSystem {
    private scene: Scene;
    private config: MurmurationInputConfig;
    private callbacks: InputSystemCallbacks;
    
    // Subsystems
    private inputManager: InputManager;
    private mobileHandler: MobileInputHandler;
    private accessibilityManager: AccessibilityManager;
    private cameraController: CameraController;
    private stateManager: InputStateManager;
    private feedbackManager: FeedbackManager;
    
    // State tracking
    private isInitialized: boolean = false;
    private currentPlatform: 'desktop' | 'mobile';
    private performanceMetrics = {\n        totalEvents: 0,\n        averageLatency: 0,\n        systemHealth: 'good' as 'good' | 'warning' | 'critical'\n    };\n    \n    constructor(scene: Scene, config: MurmurationInputConfig = {}, callbacks: InputSystemCallbacks = {}) {\n        this.scene = scene;\n        this.config = this.normalizeConfig(config);\n        this.callbacks = callbacks;\n        \n        // Detect platform\n        this.currentPlatform = this.detectPlatform();\n        \n        this.initializeSystems();\n        this.setupEventHandlers();\n        this.setupPerformanceMonitoring();\n        \n        this.isInitialized = true;\n        \n        if (this.config.debugMode) {\n            this.enableDebugMode();\n        }\n    }\n    \n    private normalizeConfig(config: MurmurationInputConfig): MurmurationInputConfig {\n        return {\n            debugMode: false,\n            performanceMode: false,\n            platform: 'auto',\n            ...config\n        };\n    }\n    \n    private detectPlatform(): 'desktop' | 'mobile' {\n        if (this.config.platform !== 'auto') {\n            return this.config.platform === 'mobile' ? 'mobile' : 'desktop';\n        }\n        \n        // Auto-detect based on touch support and screen size\n        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n        const hasSmallScreen = window.innerWidth < 768;\n        const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n        \n        return (hasTouchScreen && hasSmallScreen) || isMobile ? 'mobile' : 'desktop';\n    }\n    \n    private initializeSystems(): void {\n        // Initialize camera controller first (other systems depend on it)\n        this.cameraController = new CameraController(this.scene, this.config.camera);\n        \n        // Initialize core input systems\n        this.inputManager = new InputManager(this.scene, this.config.input);\n        this.mobileHandler = new MobileInputHandler(this.scene, this.config.mobile);\n        this.accessibilityManager = new AccessibilityManager(this.scene, this.config.accessibility);\n        \n        // Initialize state manager (coordinates all input)\n        this.stateManager = new InputStateManager(\n            this.scene,\n            this.inputManager,\n            this.mobileHandler,\n            this.accessibilityManager,\n            this.cameraController,\n            this.config.state\n        );\n        \n        // Initialize feedback system\n        this.feedbackManager = new FeedbackManager(this.scene, this.config.feedback);\n        \n        // Configure for platform\n        this.configurePlatformSpecific();\n    }\n    \n    private configurePlatformSpecific(): void {\n        if (this.currentPlatform === 'mobile') {\n            // Mobile-specific optimizations\n            this.feedbackManager.updateConfig({\n                hapticEnabled: true,\n                feedbackQuality: this.config.performanceMode ? 'low' : 'medium',\n                maxParticles: this.config.performanceMode ? 50 : 100\n            });\n            \n            this.cameraController.updateConfig({\n                smoothingFactor: 0.15, // Slightly more smoothing for touch\n                followSmoothing: 0.12\n            });\n        } else {\n            // Desktop-specific optimizations\n            this.feedbackManager.updateConfig({\n                hapticEnabled: false,\n                feedbackQuality: this.config.performanceMode ? 'medium' : 'high',\n                maxParticles: this.config.performanceMode ? 100 : 200\n            });\n            \n            this.cameraController.updateConfig({\n                smoothingFactor: 0.08, // More responsive on desktop\n                followSmoothing: 0.06\n            });\n        }\n    }\n    \n    private setupEventHandlers(): void {\n        // Input Manager Events\n        this.inputManager.addEventListener(InputEventType.BEACON_SELECT, (data) => {\n            this.handleBeaconSelect(data.type, data.index);\n        });\n        \n        this.inputManager.addEventListener(InputEventType.BEACON_PLACE, (data) => {\n            this.handleBeaconPlace(data.type, data.x, data.y);\n        });\n        \n        this.inputManager.addEventListener(InputEventType.BEACON_REMOVE, (data) => {\n            this.handleBeaconRemove(data.beacon);\n        });\n        \n        this.inputManager.addEventListener(InputEventType.PULSE_ACTIVATE, (data) => {\n            this.handlePulseActivate(data.type);\n        });\n        \n        this.inputManager.addEventListener(InputEventType.CAMERA_ZOOM, (data) => {\n            this.handleCameraChange('zoom', data.zoom);\n        });\n        \n        // Mobile Handler Events\n        this.mobileHandler.addEventListener(GestureType.DOUBLE_TAP, (event: GestureEvent) => {\n            this.handleDoubleTap(event);\n        });\n        \n        this.mobileHandler.addEventListener(GestureType.LONG_PRESS, (event: GestureEvent) => {\n            this.handleLongPress(event);\n        });\n        \n        this.mobileHandler.addEventListener(GestureType.SWIPE_UP, (event: GestureEvent) => {\n            this.handleSwipeGesture('up', event);\n        });\n        \n        this.mobileHandler.addEventListener(GestureType.THREE_FINGER_TAP, (event: GestureEvent) => {\n            this.handleThreeFingerTap(event);\n        });\n        \n        // Accessibility Events\n        this.accessibilityManager.addEventListener(AccessibilityEvent.FOCUS_CHANGED, (data) => {\n            this.handleFocusChange(data.element);\n        });\n        \n        this.accessibilityManager.addEventListener(AccessibilityEvent.ELEMENT_ACTIVATED, (data) => {\n            this.handleElementActivation(data);\n        });\n        \n        // State Manager Events\n        this.stateManager.addEventListener('state_change', (data) => {\n            this.handleStateChange(data);\n        });\n        \n        this.stateManager.addEventListener('input_conflict', (data) => {\n            this.handleInputConflict(data);\n        });\n        \n        this.stateManager.addEventListener('performance_warning', (data) => {\n            this.handlePerformanceWarning(data);\n        });\n    }\n    \n    // =========================\n    // EVENT HANDLERS\n    // =========================\n    \n    private handleBeaconSelect(type: BeaconType, index: number): void {\n        // Provide visual feedback\n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.SELECTION,\n            intensity: FeedbackIntensity.NORMAL,\n            message: `${type} beacon selected`,\n            sound: 'ui_select',\n            hapticPattern: 100\n        });\n        \n        // Notify callback\n        if (this.callbacks.onBeaconSelect) {\n            this.callbacks.onBeaconSelect(type);\n        }\n    }\n    \n    private handleBeaconPlace(type: BeaconType, x: number, y: number): void {\n        // Provide success feedback\n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.SUCCESS,\n            position: { x, y },\n            intensity: FeedbackIntensity.NORMAL,\n            message: `${type} beacon placed`,\n            sound: 'beacon_place',\n            hapticPattern: [100, 50, 100]\n        });\n        \n        // Notify callback\n        if (this.callbacks.onBeaconPlace) {\n            this.callbacks.onBeaconPlace(type, x, y);\n        }\n    }\n    \n    private handleBeaconRemove(beacon: any): void {\n        // Provide removal feedback\n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.WARNING,\n            position: beacon.position,\n            intensity: FeedbackIntensity.NORMAL,\n            message: 'Beacon removed',\n            sound: 'beacon_remove',\n            hapticPattern: 200\n        });\n        \n        // Notify callback\n        if (this.callbacks.onBeaconRemove) {\n            this.callbacks.onBeaconRemove(beacon.id);\n        }\n    }\n    \n    private handlePulseActivate(type: PulseType): void {\n        // Provide action feedback with screen effect\n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.ACTION,\n            intensity: FeedbackIntensity.STRONG,\n            message: `${type} pulse activated`,\n            sound: `pulse_${type}`,\n            hapticPattern: [50, 100, 50]\n        });\n        \n        // Notify callback\n        if (this.callbacks.onPulseActivate) {\n            this.callbacks.onPulseActivate(type);\n        }\n    }\n    \n    private handleCameraChange(changeType: string, value: any): void {\n        const camera = this.cameraController;\n        const mode = camera.getCurrentMode();\n        \n        // Subtle feedback for camera changes\n        if (changeType === 'zoom') {\n            this.feedbackManager.provideFeedback({\n                type: FeedbackType.INTERACTION,\n                intensity: FeedbackIntensity.SUBTLE,\n                message: `Zoom level: ${Math.round(value * 100)}%`\n            });\n        }\n        \n        // Notify callback\n        if (this.callbacks.onCameraChange) {\n            this.callbacks.onCameraChange(mode, this.scene.cameras.main.centerX, this.scene.cameras.main.centerY, value);\n        }\n    }\n    \n    private handleDoubleTap(event: GestureEvent): void {\n        // Double tap centers camera on flock or tapped location\n        this.cameraController.panTo(event.centerX, event.centerY);\n        \n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.INTERACTION,\n            position: { x: event.centerX, y: event.centerY },\n            intensity: FeedbackIntensity.NORMAL,\n            message: 'Camera centered',\n            hapticPattern: [80, 40, 80]\n        });\n    }\n    \n    private handleLongPress(event: GestureEvent): void {\n        // Long press opens context menu\n        this.stateManager.pushContext(InputContext.DIALOG);\n        \n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.INFO,\n            position: { x: event.centerX, y: event.centerY },\n            intensity: FeedbackIntensity.NORMAL,\n            message: 'Context menu opened',\n            hapticPattern: 200\n        });\n        \n        // Show context menu (would integrate with UI system)\n        if (this.callbacks.onGameAction) {\n            this.callbacks.onGameAction('context_menu', {\n                position: { x: event.centerX, y: event.centerY }\n            });\n        }\n    }\n    \n    private handleSwipeGesture(direction: string, event: GestureEvent): void {\n        // Swipe up could open/close UI panels\n        let action: string;\n        \n        switch (direction) {\n            case 'up':\n                action = 'toggle_ui_panel';\n                break;\n            case 'down':\n                action = 'close_panels';\n                break;\n            case 'left':\n                action = 'previous_level';\n                break;\n            case 'right':\n                action = 'next_level';\n                break;\n            default:\n                return;\n        }\n        \n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.INTERACTION,\n            intensity: FeedbackIntensity.NORMAL,\n            message: `Swipe ${direction} detected`,\n            hapticPattern: 150\n        });\n        \n        if (this.callbacks.onGameAction) {\n            this.callbacks.onGameAction(action, { direction, velocity: event.velocity });\n        }\n    }\n    \n    private handleThreeFingerTap(event: GestureEvent): void {\n        // Three finger tap could toggle accessibility mode\n        const currentConfig = this.accessibilityManager.getConfig();\n        \n        this.accessibilityManager.updateConfig({\n            highContrastMode: !currentConfig?.highContrastMode\n        });\n        \n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.INFO,\n            intensity: FeedbackIntensity.STRONG,\n            message: `High contrast mode ${!currentConfig?.highContrastMode ? 'enabled' : 'disabled'}`,\n            hapticPattern: [100, 100, 100]\n        });\n    }\n    \n    private handleFocusChange(element: any): void {\n        // Provide accessibility feedback\n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.FOCUS,\n            target: element,\n            intensity: FeedbackIntensity.SUBTLE,\n            message: `Focused on ${element.ariaLabel}`,\n            sound: 'ui_focus'\n        });\n    }\n    \n    private handleElementActivation(data: any): void {\n        // Handle accessibility activation\n        if (data.action) {\n            this.feedbackManager.provideFeedback({\n                type: FeedbackType.ACTION,\n                intensity: FeedbackIntensity.NORMAL,\n                message: `Activated ${data.action}`,\n                sound: 'ui_activate'\n            });\n            \n            if (this.callbacks.onGameAction) {\n                this.callbacks.onGameAction(data.action, data);\n            }\n        }\n    }\n    \n    private handleStateChange(data: any): void {\n        // Log state changes in debug mode\n        if (this.config.debugMode) {\n            console.log('Input state changed:', data);\n        }\n    }\n    \n    private handleInputConflict(data: any): void {\n        // Handle input conflicts\n        if (this.config.debugMode) {\n            console.warn('Input conflict detected:', data);\n        }\n        \n        // Provide feedback about conflict resolution\n        this.feedbackManager.provideFeedback({\n            type: FeedbackType.WARNING,\n            intensity: FeedbackIntensity.SUBTLE,\n            message: 'Input conflict resolved'\n        });\n    }\n    \n    private handlePerformanceWarning(data: any): void {\n        if (data.type === 'slow_processing') {\n            this.performanceMetrics.systemHealth = 'warning';\n            \n            // Auto-reduce quality if needed\n            if (this.config.performanceMode || data.processingTime > 32) {\n                this.optimizePerformance();\n            }\n        }\n        \n        if (this.callbacks.onPerformanceWarning) {\n            this.callbacks.onPerformanceWarning(data);\n        }\n    }\n    \n    // =========================\n    // PERFORMANCE MONITORING\n    // =========================\n    \n    private setupPerformanceMonitoring(): void {\n        // Monitor system health every second\n        setInterval(() => {\n            this.updatePerformanceMetrics();\n        }, 1000);\n    }\n    \n    private updatePerformanceMetrics(): void {\n        const stateMetrics = this.stateManager.getPerformanceMetrics();\n        const feedbackMetrics = this.feedbackManager.getPerformanceMetrics();\n        \n        this.performanceMetrics.totalEvents = stateMetrics.eventsProcessed;\n        this.performanceMetrics.averageLatency = stateMetrics.avgProcessingTime;\n        \n        // Determine system health\n        if (stateMetrics.frameDrops > 10 || feedbackMetrics.activeEffects > 30) {\n            this.performanceMetrics.systemHealth = 'critical';\n            this.optimizePerformance();\n        } else if (stateMetrics.frameDrops > 3 || feedbackMetrics.activeEffects > 15) {\n            this.performanceMetrics.systemHealth = 'warning';\n        } else {\n            this.performanceMetrics.systemHealth = 'good';\n        }\n    }\n    \n    private optimizePerformance(): void {\n        // Reduce feedback quality\n        this.feedbackManager.updateConfig({\n            feedbackQuality: 'low',\n            maxParticles: 50,\n            particleCount: 25\n        });\n        \n        // Reduce camera smoothing\n        this.cameraController.updateConfig({\n            smoothingFactor: 0.05\n        });\n        \n        // Increase state processing thresholds\n        this.stateManager.updateConfig({\n            inputDebounceTime: 32 // 30fps\n        });\n        \n        console.warn('Performance optimization applied');\n    }\n    \n    // =========================\n    // PUBLIC API\n    // =========================\n    \n    /**\n     * Main update loop - call from scene update\n     */\n    public update(time: number, deltaTime: number): void {\n        if (!this.isInitialized) return;\n        \n        // Update all subsystems\n        this.inputManager.update(deltaTime);\n        this.cameraController.update(deltaTime);\n        this.stateManager.update(deltaTime);\n        this.feedbackManager.update(deltaTime);\n        \n        // Accessibility manager updates itself via keyboard events\n    }\n    \n    /**\n     * Set the current input context (menu, gameplay, etc.)\n     */\n    public setContext(context: InputContext): void {\n        this.stateManager.setContext(context);\n        \n        // Update system configurations based on context\n        this.configureForContext(context);\n    }\n    \n    private configureForContext(context: InputContext): void {\n        switch (context) {\n            case InputContext.MENU:\n                // Disable game-specific inputs\n                this.inputManager.lockInput(false);\n                this.cameraController.setFreeMode();\n                break;\n                \n            case InputContext.GAMEPLAY:\n                // Enable all inputs\n                this.inputManager.lockInput(false);\n                break;\n                \n            case InputContext.PAUSED:\n                // Limited inputs\n                this.inputManager.lockInput(true);\n                break;\n                \n            case InputContext.CINEMATIC:\n            case InputContext.LOADING:\n                // Block most inputs\n                this.inputManager.lockInput(true);\n                this.feedbackManager.stopAllEffects();\n                break;\n        }\n    }\n    \n    /**\n     * Enable/disable specific input methods\n     */\n    public configureInputMethods(config: {\n        mouse?: boolean;\n        touch?: boolean;\n        keyboard?: boolean;\n    }): void {\n        if (config.mouse !== undefined) {\n            this.inputManager.updateConfig({ mouseSensitivity: config.mouse ? 1.0 : 0 });\n        }\n        \n        if (config.touch !== undefined) {\n            this.mobileHandler.updateConfig({ touchEnabled: config.touch });\n        }\n        \n        if (config.keyboard !== undefined) {\n            this.accessibilityManager.updateConfig({ keyboardNavigation: config.keyboard });\n        }\n    }\n    \n    /**\n     * Set camera to follow flock\n     */\n    public followFlock(flockData: any): void {\n        this.cameraController.followFlock(flockData);\n    }\n    \n    /**\n     * Center camera on position\n     */\n    public centerCamera(x: number, y: number, zoom?: number): void {\n        this.cameraController.panTo(x, y, zoom);\n    }\n    \n    /**\n     * Provide custom feedback\n     */\n    public provideFeedback(type: FeedbackType, options: any = {}): void {\n        this.feedbackManager.provideFeedback({\n            type,\n            ...options\n        });\n    }\n    \n    /**\n     * Get current input state\n     */\n    public getInputState(): any {\n        return {\n            state: this.stateManager.getState(),\n            context: this.stateManager.getCurrentContext(),\n            platform: this.currentPlatform,\n            performance: this.performanceMetrics\n        };\n    }\n    \n    /**\n     * Enable/disable debug mode\n     */\n    public setDebugMode(enabled: boolean): void {\n        this.config.debugMode = enabled;\n        \n        if (enabled) {\n            this.enableDebugMode();\n        } else {\n            this.disableDebugMode();\n        }\n    }\n    \n    private enableDebugMode(): void {\n        // Add debug overlay\n        const debugOverlay = this.scene.add.text(10, 10, '', {\n            fontSize: '12px',\n            color: '#00ff00',\n            backgroundColor: 'rgba(0,0,0,0.7)',\n            padding: { x: 5, y: 5 }\n        });\n        \n        debugOverlay.setScrollFactor(0);\n        debugOverlay.setDepth(9999);\n        \n        // Update debug info\n        const updateDebugInfo = () => {\n            const state = this.stateManager.getState();\n            const performance = this.performanceMetrics;\n            \n            debugOverlay.setText([\n                `Platform: ${this.currentPlatform}`,\n                `Context: ${state.context}`,\n                `Primary Input: ${state.primaryInput}`,\n                `Active Inputs: ${state.activeInputs.size}`,\n                `Performance: ${performance.systemHealth}`,\n                `Events/s: ${performance.totalEvents}`,\n                `Avg Latency: ${performance.averageLatency.toFixed(2)}ms`\n            ].join('\\n'));\n        };\n        \n        // Store update function for cleanup\n        (this as any).debugUpdateFunction = updateDebugInfo;\n        this.scene.time.addEvent({\n            delay: 100,\n            callback: updateDebugInfo,\n            loop: true\n        });\n        \n        console.log('Murmuration Input System Debug Mode Enabled');\n    }\n    \n    private disableDebugMode(): void {\n        // Remove debug overlay\n        // Implementation would clean up debug elements\n    }\n    \n    /**\n     * Reset all input systems\n     */\n    public reset(): void {\n        this.inputManager.reset();\n        this.mobileHandler.reset();\n        this.accessibilityManager.reset();\n        this.cameraController.reset();\n        this.stateManager.reset();\n        this.feedbackManager.reset();\n        \n        this.performanceMetrics = {\n            totalEvents: 0,\n            averageLatency: 0,\n            systemHealth: 'good'\n        };\n    }\n    \n    /**\n     * Clean up all systems\n     */\n    public destroy(): void {\n        this.inputManager.destroy();\n        this.mobileHandler.destroy();\n        this.accessibilityManager.destroy();\n        this.cameraController.destroy();\n        this.stateManager.destroy();\n        this.feedbackManager.destroy();\n        \n        this.isInitialized = false;\n    }\n}\n\n// =========================\n// EXAMPLE USAGE\n// =========================\n\n/**\n * Example Phaser Scene using the integrated input system\n */\nexport class ExampleGameScene extends Scene {\n    private inputSystem!: MurmurationInputSystem;\n    private gameState: any = {};\n    \n    preload() {\n        // Load required assets\n        this.load.image('particle', 'assets/particle.png');\n        this.load.audio('ui_click', ['assets/sounds/ui_click.ogg', 'assets/sounds/ui_click.mp3']);\n        this.load.audio('beacon_place', ['assets/sounds/beacon_place.ogg', 'assets/sounds/beacon_place.mp3']);\n        // ... other sound files\n    }\n    \n    create() {\n        // Initialize input system with callbacks\n        this.inputSystem = new MurmurationInputSystem(this, {\n            debugMode: true,\n            performanceMode: false,\n            platform: 'auto',\n            \n            // Configure subsystems\n            input: {\n                mouseSensitivity: 1.0\n            },\n            mobile: {\n                touchEnabled: true,\n                gesturesEnabled: true\n            },\n            accessibility: {\n                keyboardNavigation: true,\n                screenReaderSupport: true\n            },\n            camera: {\n                smoothingFactor: 0.1,\n                autoFollow: true\n            },\n            feedback: {\n                visualEnabled: true,\n                audioEnabled: true,\n                hapticEnabled: true\n            }\n        }, {\n            // Game-specific callbacks\n            onBeaconSelect: (type: BeaconType) => {\n                console.log(`Beacon selected: ${type}`);\n            },\n            \n            onBeaconPlace: (type: BeaconType, x: number, y: number) => {\n                console.log(`Beacon placed: ${type} at (${x}, ${y})`);\n                // Place beacon in game world\n                this.placeBeacon(type, x, y);\n            },\n            \n            onPulseActivate: (type: PulseType) => {\n                console.log(`Pulse activated: ${type}`);\n                // Activate pulse in simulation\n                this.activatePulse(type);\n            },\n            \n            onCameraChange: (mode, x, y, zoom) => {\n                console.log(`Camera: ${mode} at (${x}, ${y}) zoom ${zoom}`);\n            },\n            \n            onGameAction: (action: string, data: any) => {\n                console.log(`Game action: ${action}`, data);\n                this.handleGameAction(action, data);\n            },\n            \n            onPerformanceWarning: (warning) => {\n                console.warn('Performance warning:', warning);\n            }\n        });\n        \n        // Set initial context\n        this.inputSystem.setContext(InputContext.GAMEPLAY);\n        \n        // Create game objects\n        this.createGameWorld();\n    }\n    \n    update(time: number, delta: number) {\n        // Update input system\n        this.inputSystem.update(time, delta);\n        \n        // Update game simulation\n        this.updateGameSimulation(delta);\n    }\n    \n    private placeBeacon(type: BeaconType, x: number, y: number): void {\n        // Create beacon sprite\n        const beacon = this.add.sprite(x, y, `beacon_${type}`);\n        beacon.setInteractive();\n        \n        // Register as focusable element for accessibility\n        this.inputSystem.accessibilityManager?.registerFocusableElement({\n            id: `beacon_${Date.now()}`,\n            element: beacon,\n            ariaLabel: `${type} beacon`,\n            role: 'button',\n            tabIndex: 0,\n            bounds: { x: x - 25, y: y - 25, width: 50, height: 50 }\n        });\n    }\n    \n    private activatePulse(type: PulseType): void {\n        // Create visual pulse effect\n        const pulseEffect = this.add.graphics();\n        pulseEffect.lineStyle(5, 0x4fbdba);\n        pulseEffect.strokeCircle(0, 0, 100);\n        pulseEffect.setPosition(this.cameras.main.centerX, this.cameras.main.centerY);\n        \n        // Animate pulse\n        this.tweens.add({\n            targets: pulseEffect,\n            scaleX: 5,\n            scaleY: 5,\n            alpha: 0,\n            duration: 1000,\n            onComplete: () => pulseEffect.destroy()\n        });\n    }\n    \n    private handleGameAction(action: string, data: any): void {\n        switch (action) {\n            case 'context_menu':\n                this.showContextMenu(data.position);\n                break;\n            case 'toggle_ui_panel':\n                this.toggleUIPanel();\n                break;\n            // ... other actions\n        }\n    }\n    \n    private createGameWorld(): void {\n        // Create game world elements\n        // This would create the actual game content\n    }\n    \n    private updateGameSimulation(delta: number): void {\n        // Update game simulation\n        // This would update birds, hazards, etc.\n    }\n    \n    private showContextMenu(position: { x: number; y: number }): void {\n        // Show context menu\n        console.log('Context menu at', position);\n    }\n    \n    private toggleUIPanel(): void {\n        // Toggle UI panel\n        console.log('Toggle UI panel');\n    }\n}\n\n// Export the main class and example\nexport { MurmurationInputSystem as default, ExampleGameScene };
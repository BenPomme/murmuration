<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Murmuration Genetics - Breed Your Flock</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f3460 100%);
            color: white;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Header */
        .header {
            background: rgba(22, 33, 62, 0.95);
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #4fbdba;
            flex-shrink: 0;
            min-height: 50px;
        }
        
        .title {
            font-size: 22px;
            font-weight: bold;
            background: linear-gradient(90deg, #4fbdba, #4ade80);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .generation-info {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 18px;
        }
        
        .gen-display {
            padding: 5px 15px;
            background: rgba(79, 189, 186, 0.2);
            border: 1px solid #4fbdba;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .population-counts {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .gender-count {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
        }
        
        .male-count {
            color: #3b82f6;
        }
        
        .female-count {
            color: #ec4899;
        }
        
        /* Main container */
        .main-container {
            flex: 1;
            display: flex;
            min-height: 0;
            overflow: hidden;
        }
        
        /* Left panel - Statistics */
        .stats-panel {
            width: 280px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px;
            overflow-y: auto;
            border-right: 1px solid #0f3460;
            flex-shrink: 0;
        }
        
        .stat-section {
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(79, 189, 186, 0.2);
        }
        
        .stat-title {
            font-size: 12px;
            color: #4fbdba;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        /* Genetic trait bars */
        .trait-display {
            margin: 6px 0;
        }
        
        .trait-label {
            font-size: 11px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        
        .trait-bar {
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        
        .trait-fill {
            height: 100%;
            background: linear-gradient(90deg, #e94560, #fbbf24, #4ade80);
            transition: width 0.5s ease;
        }
        
        .trait-variance {
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(255,255,255,0.3);
            pointer-events: none;
        }
        
        /* Population pyramid */
        .population-pyramid {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 10px 0;
        }
        
        .pyramid-bar {
            height: 20px;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            transition: width 0.5s;
        }
        
        .pyramid-bar.female {
            background: linear-gradient(90deg, #ec4899, #f9a8d4);
        }
        
        .pyramid-label {
            font-size: 10px;
            color: #888;
            min-width: 30px;
            text-align: center;
        }
        
        /* Game canvas */
        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #gameCanvas {
            flex: 1;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
            cursor: crosshair;
            display: block;
        }
        
        /* Right panel - Family trees */
        .family-panel {
            width: 300px;
            background: rgba(22, 33, 62, 0.9);
            padding: 10px;
            overflow-y: auto;
            border-left: 1px solid #0f3460;
            flex-shrink: 0;
        }
        
        /* Family tree display */
        .family-tree {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            font-size: 12px;
        }
        
        .tree-node {
            margin: 5px 0;
            padding: 5px;
            background: rgba(79, 189, 186, 0.1);
            border-left: 2px solid #4fbdba;
            border-radius: 3px;
        }
        
        .tree-node.male {
            border-left-color: #3b82f6;
        }
        
        .tree-node.female {
            border-left-color: #ec4899;
        }
        
        .tree-node.champion {
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.2), rgba(79, 189, 186, 0.2));
            border-left-width: 3px;
        }
        
        /* Bloodline hall of fame */
        .bloodline-card {
            margin: 8px 0;
            padding: 8px;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(79, 189, 186, 0.1));
            border: 1px solid #fbbf24;
            border-radius: 5px;
            font-size: 11px;
        }
        
        .bloodline-title {
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 4px;
        }
        
        .bloodline-stat {
            display: flex;
            justify-content: space-between;
            color: #aaa;
        }
        
        /* Breeding animation overlay */
        .breeding-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 33, 62, 0.98);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #4fbdba;
            text-align: center;
            z-index: 1000;
            min-width: 400px;
        }
        
        .breeding-overlay.show {
            display: block;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        .breeding-title {
            font-size: 24px;
            margin-bottom: 20px;
            color: #4fbdba;
        }
        
        .breeding-stats {
            margin: 15px 0;
            font-size: 16px;
            line-height: 1.8;
        }
        
        .pair-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 15px 0;
        }
        
        .parent-bird {
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            min-width: 80px;
        }
        
        .heart-animation {
            font-size: 30px;
            animation: heartbeat 1s infinite;
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }
        
        /* Controls */
        .controls {
            background: rgba(22, 33, 62, 0.95);
            padding: 8px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            border-top: 2px solid #0f3460;
            flex-shrink: 0;
            min-height: 45px;
        }
        
        button, select {
            padding: 6px 12px;
            background: #0f3460;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
        }
        
        button:hover:not(:disabled), select:hover:not(:disabled) {
            background: #1e5f8e;
            transform: translateY(-1px);
        }
        
        button:disabled, select:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.primary {
            background: linear-gradient(135deg, #4fbdba, #4ade80);
            color: #16213e;
            font-weight: bold;
        }
        
        /* Diversity indicator */
        .diversity-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 20px;
        }
        
        .diversity-label {
            font-size: 11px;
            color: #888;
        }
        
        .diversity-bar {
            width: 100px;
            height: 8px;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .diversity-fill {
            height: 100%;
            background: linear-gradient(90deg, #ef4444, #fbbf24, #4ade80);
            transition: width 0.5s;
        }
        
        /* Beacon controls */
        .beacon-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(22, 33, 62, 0.9);
            padding: 8px;
            border-radius: 8px;
            z-index: 10;
        }
        
        .beacon-btn {
            padding: 8px 12px;
            background: linear-gradient(135deg, #0f3460, #1e5f8e);
            color: white;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .beacon-btn.selected {
            border-color: #4fbdba;
            background: linear-gradient(135deg, #1e5f8e, #4fbdba);
        }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }
        
        .tooltip.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">🧬 MURMURATION GENETICS</div>
        
        <div class="generation-info">
            <div class="gen-display">Generation <span id="generation">0</span></div>
            <div class="diversity-meter">
                <span class="diversity-label">Diversity:</span>
                <div class="diversity-bar">
                    <div class="diversity-fill" id="diversity-bar" style="width: 50%"></div>
                </div>
            </div>
        </div>
        
        <div class="population-counts">
            <div class="gender-count" style="background: linear-gradient(135deg, #3b82f6, #60a5fa);">
                🦅 Flying: <span id="flying-count">100</span>
            </div>
            <div class="gender-count" style="background: linear-gradient(135deg, #10b981, #34d399);">
                ✅ Safe: <span id="safe-count">0</span>
            </div>
            <div class="gender-count" style="background: linear-gradient(135deg, #ef4444, #f87171);">
                💀 Lost: <span id="lost-count">0</span>
            </div>
        </div>
    </div>
    
    <div class="main-container">
        <!-- Left Statistics Panel -->
        <div class="stats-panel">
            <div class="stat-section">
                <div class="stat-title">📊 Population Genetics</div>
                
                <div class="trait-display">
                    <div class="trait-label">
                        <span>Hazard Awareness</span>
                        <span id="awareness-val">50%</span>
                    </div>
                    <div class="trait-bar">
                        <div class="trait-fill" id="awareness-bar" style="width: 50%"></div>
                        <div class="trait-variance" id="awareness-var"></div>
                    </div>
                </div>
                
                <div class="trait-display">
                    <div class="trait-label">
                        <span>Energy Efficiency</span>
                        <span id="efficiency-val">50%</span>
                    </div>
                    <div class="trait-bar">
                        <div class="trait-fill" id="efficiency-bar" style="width: 50%"></div>
                        <div class="trait-variance" id="efficiency-var"></div>
                    </div>
                </div>
                
                <div class="trait-display">
                    <div class="trait-label">
                        <span>Flock Cohesion</span>
                        <span id="cohesion-val">50%</span>
                    </div>
                    <div class="trait-bar">
                        <div class="trait-fill" id="cohesion-bar" style="width: 50%"></div>
                        <div class="trait-variance" id="cohesion-var"></div>
                    </div>
                </div>
                
                <div class="trait-display">
                    <div class="trait-label">
                        <span>Beacon Response</span>
                        <span id="beacon-val">50%</span>
                    </div>
                    <div class="trait-bar">
                        <div class="trait-fill" id="beacon-bar" style="width: 50%"></div>
                        <div class="trait-variance" id="beacon-var"></div>
                    </div>
                </div>
                
                <div class="trait-display">
                    <div class="trait-label">
                        <span>Stress Resilience</span>
                        <span id="resilience-val">50%</span>
                    </div>
                    <div class="trait-bar">
                        <div class="trait-fill" id="resilience-bar" style="width: 50%"></div>
                        <div class="trait-variance" id="resilience-var"></div>
                    </div>
                </div>
            </div>
            
            <div class="stat-section">
                <div class="stat-title">👥 Population Pyramid</div>
                <div id="population-pyramid">
                    <!-- Dynamically generated -->
                </div>
            </div>
            
            <div class="stat-section">
                <div class="stat-title">📈 Level Progress</div>
                <div style="font-size: 12px; line-height: 1.6;">
                    Safe Arrivals: <span id="arrivals" style="color: #4ade80">0</span> / 80<br>
                    Birds Lost: <span id="losses" style="color: #ef4444">0</span> / 20 max<br>
                    Time: <span id="timer">2:00</span><br>
                    Breeding Pairs: <span id="pairs-ready" style="color: #ec4899">0</span>
                </div>
                <div id="level-status" style="margin-top: 10px; font-weight: bold; text-align: center;"></div>
            </div>
        </div>
        
        <!-- Center Game Area -->
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            
            <!-- Beacon controls -->
            <div class="beacon-controls">
                <button class="beacon-btn" data-beacon="food">🍎 Food</button>
                <button class="beacon-btn" data-beacon="shelter">🛡️ Shelter</button>
                <button class="beacon-btn" data-beacon="thermal">🌀 Thermal</button>
                <span style="margin: 0 10px; color: #888;">Budget: <span id="beacon-count">4</span></span>
            </div>
            
            <!-- Breeding overlay -->
            <div class="breeding-overlay" id="breeding-overlay">
                <div class="breeding-title">💕 Breeding Season!</div>
                <div class="breeding-stats">
                    <div class="pair-display">
                        <div class="parent-bird">
                            ♂ <span id="male-survivors">0</span>
                        </div>
                        <div class="heart-animation">❤️</div>
                        <div class="parent-bird">
                            ♀ <span id="female-survivors">0</span>
                        </div>
                    </div>
                    <div>
                        <strong>Automatic Breeding Complete!</strong><br>
                        Pairs Formed: <span id="pairs-formed">0</span><br>
                        Offspring Created: <span id="offspring-count">0</span><br>
                        Survivors Kept: <span id="survivors-kept">0</span><br>
                        New Generation: <span id="new-gen">1</span><br>
                        Total Population: <span id="total-pop">100</span>
                    </div>
                </div>
                <button onclick="continueGame()" class="primary" style="margin-top: 15px;">Continue Playing</button>
            </div>
        </div>
        
        <!-- Right Family Panel -->
        <div class="family-panel">
            <div class="stat-section">
                <div class="stat-title">🏆 Hall of Fame</div>
                <div id="hall-of-fame">
                    <!-- Dynamically generated -->
                </div>
            </div>
            
            <div class="stat-section">
                <div class="stat-title">🌳 Selected Bird</div>
                <div id="selected-bird-info" style="font-size: 11px; color: #aaa;">
                    Click on a bird to see its family tree
                </div>
            </div>
            
            <div class="stat-section">
                <div class="stat-title">👑 Top Bloodlines</div>
                <div id="top-bloodlines">
                    <!-- Dynamically generated -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button id="connect-btn" onclick="connect()" class="primary">CONNECT</button>
        <button id="reset-btn" onclick="resetToGenZero()" disabled>RESET TO GEN 0</button>
        <select id="level-select" disabled>
            <option value="W1-1">W1-1: First Flight</option>
            <option value="W1-2">W1-2: Predator Valley</option>
            <option value="W2-1">W2-1: Storm Front</option>
            <option value="W2-2">W2-2: The Gauntlet</option>
            <option value="W3-1">W3-1: Migration Marathon</option>
            <option value="W3-2">W3-2: Apex Predators</option>
            <option value="W4-1">W4-1: Perfect Storm</option>
            <option value="W4-2">W4-2: Fog of War</option>
            <option value="W5-1">W5-1: Turbulent Skies</option>
            <option value="W5-2">W5-2: Electric Storm</option>
            <option value="W6-1">W6-1: The Maelstrom</option>
        </select>
        <button id="start-btn" onclick="startGame()" disabled>START</button>
        <button onclick="setSpeed(0.5)">0.5x</button>
        <button onclick="setSpeed(1)" class="primary">1x</button>
        <button onclick="setSpeed(2)">2x</button>
        <button onclick="savePopulation()">SAVE</button>
        <button onclick="loadPopulation()">LOAD</button>
    </div>
    
    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        // Game state
        let ws = null;
        let gameState = null;
        let selectedBird = null;
        let selectedBeacon = null;
        let beaconBudget = 4;
        let currentLevel = 'W1-1';
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Particle system for visual effects
        const particles = [];
        class Particle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.life = 1.0;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                
                if (type === 'arrival') {
                    this.color = 'rgba(74, 222, 128, ';
                    this.size = Math.random() * 3 + 2;
                    this.vx *= 3;
                    this.vy *= 3;
                } else if (type === 'stress') {
                    this.color = 'rgba(239, 68, 68, ';
                    this.size = Math.random() * 2 + 1;
                } else if (type === 'energy') {
                    this.color = 'rgba(255, 193, 7, ';
                    this.size = Math.random() * 2 + 1;
                }
            }
            
            update(dt) {
                this.x += this.vx * dt * 60;
                this.y += this.vy * dt * 60;
                this.life -= dt * 2;
                this.vy += dt * 10; // gravity
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.fillStyle = this.color + (this.life * 0.8) + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function addParticles(x, y, type, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push(new Particle(x, y, type));
            }
        }
        
        // Resize canvas
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            console.log('Canvas resized:', canvas.width, 'x', canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Start animation loop 
        function animate() {
            if (gameState) {
                renderGame();
            }
            requestAnimationFrame(animate);
        }
        animate();
        
        // Beacon selection
        document.querySelectorAll('.beacon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (beaconBudget <= 0) return;
                document.querySelectorAll('.beacon-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedBeacon = btn.dataset.beacon;
            });
        });
        
        // Canvas click handling
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * 2000;
            const y = (e.clientY - rect.top) / rect.height * 1200;
            
            if (selectedBeacon && beaconBudget > 0) {
                // Place beacon
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'place_beacon',
                        beacon: { type: selectedBeacon, x: x, y: y }
                    }));
                    beaconBudget--;
                    document.getElementById('beacon-count').textContent = beaconBudget;
                    selectedBeacon = null;
                    document.querySelectorAll('.beacon-btn').forEach(b => b.classList.remove('selected'));
                }
            } else {
                // Select bird
                if (gameState && gameState.birds) {
                    const scaleX = canvas.width / 2000;
                    const scaleY = canvas.height / 1200;
                    
                    for (let bird of gameState.birds) {
                        const bx = bird.x * scaleX;
                        const by = bird.y * scaleY;
                        const dist = Math.sqrt(Math.pow(e.clientX - rect.left - bx, 2) + 
                                              Math.pow(e.clientY - rect.top - by, 2));
                        if (dist < 15) {
                            selectBird(bird);
                            break;
                        }
                    }
                }
            }
        });
        
        // Bird hover
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const tooltip = document.getElementById('tooltip');
            
            if (gameState && gameState.birds) {
                const scaleX = canvas.width / 2000;
                const scaleY = canvas.height / 1200;
                let found = false;
                
                for (let bird of gameState.birds) {
                    const bx = bird.x * scaleX;
                    const by = bird.y * scaleY;
                    const dist = Math.sqrt(Math.pow(e.clientX - rect.left - bx, 2) + 
                                          Math.pow(e.clientY - rect.top - by, 2));
                    if (dist < 10) {
                        showBirdTooltip(bird, e.clientX, e.clientY);
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    tooltip.classList.remove('show');
                }
            }
        });
        
        function connect() {
            if (ws) {
                ws.close();
                return;
            }
            
            console.log('Creating WebSocket connection...');
            ws = new WebSocket('ws://localhost:8765');
            
            ws.onopen = () => {
                console.log('WebSocket opened successfully');
                document.getElementById('connect-btn').textContent = 'DISCONNECT';
                document.getElementById('level-select').disabled = false;
                document.getElementById('start-btn').disabled = false;
                document.getElementById('reset-btn').disabled = false;
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
            
            ws.onclose = () => {
                document.getElementById('connect-btn').textContent = 'CONNECT';
                document.getElementById('level-select').disabled = true;
                document.getElementById('start-btn').disabled = true;
                document.getElementById('reset-btn').disabled = true;
                ws = null;
            };
            
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                console.log('WebSocket message received:', msg.type);
                if (msg.type === 'state_update') {
                    gameState = msg.data;
                    console.log('State update received:', {
                        birds: gameState.birds?.length || 0,
                        population: gameState.population,
                        tick: gameState.tick
                    });
                    updateGame();
                    // renderGame is called by animation loop
                } else if (msg.type === 'breeding_complete') {
                    console.log('Breeding complete received:', msg.data);
                    showBreedingResults(msg.data);
                } else if (msg.type === 'reset_complete') {
                    console.log('Reset complete received:', msg);
                    alert('Reset to Generation 0 successful! You can now start fresh.');
                    gameState = null;
                } else if (msg.type === 'error') {
                    console.error('Server error:', msg.message);
                    alert('Error: ' + msg.message);
                }
            };
        }
        
        function startGame() {
            if (!ws) {
                console.error('Cannot start game: WebSocket not connected');
                return;
            }
            
            currentLevel = document.getElementById('level-select').value;
            beaconBudget = 4;
            document.getElementById('beacon-count').textContent = beaconBudget;
            document.getElementById('breeding-overlay').classList.remove('show');
            
            const message = { 
                type: 'start_genetic',
                level: currentLevel
            };
            console.log('Sending start_genetic message:', message);
            ws.send(JSON.stringify(message));
            
            // Force a render attempt after a short delay
            setTimeout(() => {
                console.log('Forcing render after start...');
                renderGame();
            }, 100);
        }
        
        function resetToGenZero() {
            if (!ws) {
                console.error('Cannot reset: WebSocket not connected');
                return;
            }
            
            if (confirm('Are you sure you want to reset to Generation 0? This will lose all your evolved birds.')) {
                console.log('Resetting to Generation 0');
                const message = {
                    type: 'reset_to_gen_zero'
                };
                ws.send(JSON.stringify(message));
                
                // Reset UI elements
                document.getElementById('level-select').selectedIndex = 0;
                document.getElementById('breeding-overlay').classList.remove('show');
                
                // Clear any ongoing game
                gameState = null;
            }
        }
        
        let lastArrivals = 0; // Track arrivals for particle effects
        
        function updateGame() {
            if (!gameState) return;
            
            // Check for new arrivals and add celebration particles
            if (gameState.arrivals > lastArrivals) {
                const newArrivals = gameState.arrivals - lastArrivals;
                if (gameState.destination) {
                    const scaleX = canvas.width / 2000;
                    const scaleY = canvas.height / 1200;
                    const [dx, dy] = gameState.destination;
                    for (let i = 0; i < newArrivals; i++) {
                        addParticles(dx * scaleX, dy * scaleY, 'arrival', 15);
                    }
                }
                lastArrivals = gameState.arrivals;
            }
            
            // Update header - show bird status clearly
            document.getElementById('generation').textContent = gameState.generation || 0;
            
            // Calculate bird status
            const flyingBirds = gameState.population || 0;
            const safeBirds = gameState.arrivals || 0;
            const lostBirds = gameState.losses || 0;
            
            // Update bird status counters
            document.getElementById('flying-count').textContent = flyingBirds;
            document.getElementById('safe-count').textContent = safeBirds;
            document.getElementById('lost-count').textContent = lostBirds;
            
            // Update level stats
            document.getElementById('arrivals').textContent = safeBirds;
            document.getElementById('losses').textContent = lostBirds;
            
            // Calculate breeding pairs from safe arrivals
            const malesSafe = Math.floor(safeBirds / 2);
            const femalesSafe = Math.ceil(safeBirds / 2);
            const pairsReady = Math.min(malesSafe, femalesSafe);
            document.getElementById('pairs-ready').textContent = pairsReady;
            
            // Show level status
            const statusDiv = document.getElementById('level-status');
            if (gameState.game_over) {
                if (gameState.victory) {
                    statusDiv.innerHTML = '<span style="color: #10b981;">🎉 VICTORY! Breeding...</span>';
                } else if (lostBirds > 20) {
                    statusDiv.innerHTML = '<span style="color: #ef4444;">😢 Too many losses!</span>';
                } else {
                    statusDiv.innerHTML = '<span style="color: #f59e0b;">⏰ Time\'s up!</span>';
                }
            } else {
                statusDiv.innerHTML = '';
            }
            
            // Update timer
            const time = gameState.time_remaining || 120;
            const mins = Math.floor(time / 60);
            const secs = Math.floor(time % 60);
            document.getElementById('timer').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            // Calculate breeding pairs
            const males = gameState.males || 0;
            const females = gameState.females || 0;
            document.getElementById('pairs-ready').textContent = Math.min(males, females);
            
            // Update population genetics
            if (gameState.population_stats) {
                const stats = gameState.population_stats;
                
                // Update trait bars
                updateTraitBar('awareness', stats.avg_hazard_awareness || 0.5);
                updateTraitBar('efficiency', stats.avg_energy_efficiency || 0.5);
                updateTraitBar('cohesion', stats.avg_flock_cohesion || 0.5);
                updateTraitBar('beacon', stats.avg_beacon_sensitivity || 0.5);
                updateTraitBar('resilience', stats.avg_stress_resilience || 0.5);
                
                // Update diversity
                const diversity = stats.genetic_diversity || 0;
                document.getElementById('diversity-bar').style.width = `${diversity * 100}%`;
                
                // Update top bloodlines
                if (stats.top_bloodlines) {
                    updateBloodlines(stats.top_bloodlines);
                }
            }
            
            // Enable breeding if level complete
            // Breeding happens automatically now
        }
        
        function updateTraitBar(trait, value) {
            const bar = document.getElementById(`${trait}-bar`);
            const val = document.getElementById(`${trait}-val`);
            if (bar) bar.style.width = `${value * 100}%`;
            if (val) val.textContent = `${Math.round(value * 100)}%`;
        }
        
        function updateBloodlines(bloodlines) {
            const container = document.getElementById('top-bloodlines');
            container.innerHTML = '';
            
            bloodlines.slice(0, 3).forEach((line, idx) => {
                const card = document.createElement('div');
                card.className = 'bloodline-card';
                card.innerHTML = `
                    <div class="bloodline-title">#${idx + 1} Bird ${line.id} (${line.gender})</div>
                    <div class="bloodline-stat">
                        <span>Generation:</span>
                        <span>${line.generation}</span>
                    </div>
                    <div class="bloodline-stat">
                        <span>Offspring:</span>
                        <span>${line.offspring_count}</span>
                    </div>
                    <div class="bloodline-stat">
                        <span>Successful:</span>
                        <span>${line.successful_offspring}</span>
                    </div>
                `;
                container.appendChild(card);
            });
        }
        
        function renderGame() {
            if (!gameState) {
                console.log('No gameState to render');
                return;
            }
            
            console.log('Rendering game:', {
                birds: gameState.birds?.length || 0,
                canvas: {width: canvas.width, height: canvas.height},
                population: gameState.population,
                generation: gameState.generation
            });
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw gradient sky background with dynamic lighting
            const time = Date.now() * 0.0001;
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            const brightness = Math.sin(time) * 0.05 + 0.95;
            gradient.addColorStop(0, `hsl(197, 71%, ${60 * brightness}%)`);
            gradient.addColorStop(0.5, `hsl(193, 66%, ${70 * brightness}%)`);
            gradient.addColorStop(1, `hsl(189, 53%, ${75 * brightness}%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add subtle cloud effects
            ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
            for (let i = 0; i < 5; i++) {
                const x = (Math.sin(time + i) * 0.5 + 0.5) * canvas.width;
                const y = 100 + i * 50;
                const size = 200 + Math.sin(time * 2 + i) * 50;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const scaleX = canvas.width / 2000;
            const scaleY = canvas.height / 1200;
            
            // Draw destination zone with animated effect
            if (gameState.destination) {
                const [dx, dy, dr] = gameState.destination;
                const pulse = Math.sin(Date.now() * 0.002) * 0.1 + 0.9;
                
                // Animated rings
                for (let i = 0; i < 3; i++) {
                    const offset = (Date.now() * 0.001 + i * 2) % 6;
                    const alpha = Math.max(0, 1 - offset / 6);
                    ctx.strokeStyle = `rgba(74, 222, 128, ${alpha * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(dx * scaleX, dy * scaleY, (dr + offset * 10) * scaleX, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Main destination zone
                const gradient = ctx.createRadialGradient(
                    dx * scaleX, dy * scaleY, 0,
                    dx * scaleX, dy * scaleY, dr * scaleX * pulse
                );
                gradient.addColorStop(0, 'rgba(74, 222, 128, 0.4)');
                gradient.addColorStop(0.7, 'rgba(74, 222, 128, 0.2)');
                gradient.addColorStop(1, 'rgba(74, 222, 128, 0.05)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(dx * scaleX, dy * scaleY, dr * scaleX, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = 'rgba(74, 222, 128, 0.8)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Label
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('SAFE ZONE', dx * scaleX, dy * scaleY);
            }
            
            // Draw hazards with visual effects
            if (gameState.hazards) {
                gameState.hazards.forEach(hazard => {
                    const x = hazard.x * scaleX;
                    const y = hazard.y * scaleY;
                    const r = (hazard.radius || 100) * scaleX;
                    
                    if (hazard.type === 'storm' || hazard.type === 'tornado') {
                        // Draw tornado/storm with swirl effect
                        const spin = hazard.rotating ? Date.now() * 0.005 : Date.now() * 0.002;
                        
                        // Lightning effect for storms with lightning
                        if (hazard.lightning && Math.random() < 0.05) {
                            ctx.strokeStyle = 'rgba(255, 255, 100, 0.8)';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            const lx = x + (Math.random() - 0.5) * r;
                            const ly = y + (Math.random() - 0.5) * r;
                            ctx.moveTo(lx, ly - 20);
                            ctx.lineTo(lx + 10, ly);
                            ctx.lineTo(lx - 5, ly + 10);
                            ctx.lineTo(lx + 5, ly + 30);
                            ctx.stroke();
                        }
                        
                        // Outer danger zone
                        const stormGradient = ctx.createRadialGradient(x, y, 0, x, y, r * 1.5);
                        stormGradient.addColorStop(0, 'rgba(107, 114, 128, 0.6)');
                        stormGradient.addColorStop(0.5, 'rgba(107, 114, 128, 0.3)');
                        stormGradient.addColorStop(1, 'rgba(107, 114, 128, 0.05)');
                        
                        ctx.fillStyle = stormGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Swirl lines for rotating storms
                        if (hazard.rotating) {
                            ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)';
                            ctx.lineWidth = 2;
                            for (let i = 0; i < 6; i++) {
                                ctx.beginPath();
                                const angle = spin + (i * Math.PI / 3);
                                ctx.arc(x, y, r * 0.7, angle, angle + Math.PI / 3);
                                ctx.stroke();
                            }
                        }
                        
                        // Icon
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(hazard.lightning ? '⛈️' : '🌪️', x, y);
                        
                    } else if (hazard.type === 'predator') {
                        // Draw predator with pulsing red zone
                        const pulse = Math.sin(Date.now() * 0.005) * 0.1 + 0.9;
                        
                        // Danger zone
                        const predatorGradient = ctx.createRadialGradient(x, y, 0, x, y, r * pulse);
                        if (hazard.alpha) {
                            predatorGradient.addColorStop(0, 'rgba(139, 0, 0, 0.6)');
                            predatorGradient.addColorStop(0.7, 'rgba(139, 0, 0, 0.3)');
                            predatorGradient.addColorStop(1, 'rgba(139, 0, 0, 0)');
                        } else {
                            predatorGradient.addColorStop(0, 'rgba(239, 68, 68, 0.5)');
                            predatorGradient.addColorStop(0.7, 'rgba(239, 68, 68, 0.2)');
                            predatorGradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
                        }
                        
                        ctx.fillStyle = predatorGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Warning circle
                        ctx.strokeStyle = hazard.alpha ? 'rgba(139, 0, 0, 0.8)' : 'rgba(239, 68, 68, 0.6)';
                        ctx.lineWidth = hazard.alpha ? 3 : 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Predator icon
                        ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
                        ctx.font = hazard.alpha ? '28px Arial' : '24px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🦅', x, y);
                        
                    } else if (hazard.type === 'fog') {
                        // Draw fog bank with cloudy effect
                        const fogGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                        fogGradient.addColorStop(0, 'rgba(200, 200, 200, 0.7)');
                        fogGradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.4)');
                        fogGradient.addColorStop(1, 'rgba(200, 200, 200, 0.1)');
                        
                        ctx.fillStyle = fogGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Cloud particles
                        for (let i = 0; i < 5; i++) {
                            const offset = Date.now() * 0.0001 * (i + 1);
                            const px = x + Math.sin(offset) * r * 0.7;
                            const py = y + Math.cos(offset * 1.3) * r * 0.7;
                            ctx.fillStyle = 'rgba(220, 220, 220, 0.3)';
                            ctx.beginPath();
                            ctx.arc(px, py, r * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Icon
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🌫️', x, y);
                        
                    } else if (hazard.type === 'turbulence') {
                        // Draw turbulence with chaotic swirls
                        const shake = Math.sin(Date.now() * 0.01) * 5;
                        
                        const turbGradient = ctx.createRadialGradient(x + shake, y, 0, x, y, r);
                        turbGradient.addColorStop(0, 'rgba(100, 200, 255, 0.4)');
                        turbGradient.addColorStop(0.5, 'rgba(100, 200, 255, 0.2)');
                        turbGradient.addColorStop(1, 'rgba(100, 200, 255, 0)');
                        
                        ctx.fillStyle = turbGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Chaotic lines
                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < 8; i++) {
                            ctx.beginPath();
                            const angle = (Date.now() * 0.002 * (i % 2 ? 1 : -1)) + (i * Math.PI / 4);
                            const endX = x + Math.cos(angle) * r * 0.8;
                            const endY = y + Math.sin(angle) * r * 0.8;
                            ctx.moveTo(x, y);
                            ctx.quadraticCurveTo(
                                x + Math.random() * 40 - 20,
                                y + Math.random() * 40 - 20,
                                endX, endY
                            );
                            ctx.stroke();
                        }
                        
                        // Icon
                        ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('💨', x, y);
                        
                    } else if (hazard.type === 'electric_field') {
                        // Draw electric field with sparks
                        const elecGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                        elecGradient.addColorStop(0, 'rgba(255, 255, 0, 0.5)');
                        elecGradient.addColorStop(0.5, 'rgba(255, 200, 0, 0.3)');
                        elecGradient.addColorStop(1, 'rgba(255, 150, 0, 0.1)');
                        
                        ctx.fillStyle = elecGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Electric sparks
                        if (Math.random() < 0.1) {
                            ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
                            ctx.lineWidth = 2;
                            for (let i = 0; i < 3; i++) {
                                ctx.beginPath();
                                const startAngle = Math.random() * Math.PI * 2;
                                const startR = Math.random() * r * 0.5;
                                const endAngle = startAngle + (Math.random() - 0.5) * Math.PI;
                                const endR = startR + Math.random() * r * 0.5;
                                
                                ctx.moveTo(
                                    x + Math.cos(startAngle) * startR,
                                    y + Math.sin(startAngle) * startR
                                );
                                ctx.lineTo(
                                    x + Math.cos(endAngle) * endR,
                                    y + Math.sin(endAngle) * endR
                                );
                                ctx.stroke();
                            }
                        }
                        
                        // Icon
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.9)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('⚡', x, y);
                    }
                });
            }
            
            // Draw beacons
            if (gameState.beacons) {
                gameState.beacons.forEach(beacon => {
                    const x = beacon.x * scaleX;
                    const y = beacon.y * scaleY;
                    const r = (beacon.radius || 150) * scaleX;
                    
                    // Beacon effect area
                    const beaconGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                    
                    if (beacon.type === 'food') {
                        beaconGradient.addColorStop(0, 'rgba(255, 193, 7, 0.4)');
                        beaconGradient.addColorStop(0.5, 'rgba(255, 193, 7, 0.2)');
                        beaconGradient.addColorStop(1, 'rgba(255, 193, 7, 0)');
                        
                        ctx.fillStyle = beaconGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Icon
                        ctx.fillStyle = 'rgba(255, 193, 7, 0.9)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🍎', x, y);
                        
                    } else if (beacon.type === 'shelter') {
                        beaconGradient.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
                        beaconGradient.addColorStop(0.5, 'rgba(59, 130, 246, 0.2)');
                        beaconGradient.addColorStop(1, 'rgba(59, 130, 246, 0)');
                        
                        ctx.fillStyle = beaconGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Icon
                        ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🛡️', x, y);
                        
                    } else if (beacon.type === 'thermal') {
                        beaconGradient.addColorStop(0, 'rgba(239, 68, 68, 0.4)');
                        beaconGradient.addColorStop(0.5, 'rgba(239, 68, 68, 0.2)');
                        beaconGradient.addColorStop(1, 'rgba(239, 68, 68, 0)');
                        
                        ctx.fillStyle = beaconGradient;
                        ctx.beginPath();
                        ctx.arc(x, y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Icon
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('🔥', x, y);
                    }
                    
                    // Beacon range indicator
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 10]);
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                });
            }
            
            // Draw birds with gender colors and family connections
            if (gameState.birds) {
                // Draw family connections first (subtle)
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                gameState.birds.forEach(bird => {
                    if (bird.partner_id) {
                        const partner = gameState.birds.find(b => b.id === bird.partner_id);
                        if (partner) {
                            ctx.beginPath();
                            ctx.moveTo(bird.x * scaleX, bird.y * scaleY);
                            ctx.lineTo(partner.x * scaleX, partner.y * scaleY);
                            ctx.stroke();
                        }
                    }
                });
                
                // Draw birds with improved visuals
                gameState.birds.forEach((bird, index) => {
                    const x = bird.x * scaleX;
                    const y = bird.y * scaleY;
                    
                    ctx.save();
                    ctx.translate(x, y);
                    const angle = Math.atan2(bird.vy, bird.vx);
                    ctx.rotate(angle);
                    
                    // Size based on genetics
                    const size = 10 * (bird.genetics?.size_factor || 1);
                    
                    // Trail effect based on speed
                    const speed = Math.sqrt(bird.vx * bird.vx + bird.vy * bird.vy);
                    if (speed > 20) {
                        const trailGradient = ctx.createLinearGradient(-size * 2, 0, 0, 0);
                        if (bird.gender === 'male') {
                            trailGradient.addColorStop(0, 'rgba(100, 150, 255, 0)');
                            trailGradient.addColorStop(1, 'rgba(100, 150, 255, 0.3)');
                        } else {
                            trailGradient.addColorStop(0, 'rgba(255, 150, 200, 0)');
                            trailGradient.addColorStop(1, 'rgba(255, 150, 200, 0.3)');
                        }
                        ctx.fillStyle = trailGradient;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-size * 2, -size/2);
                        ctx.lineTo(-size * 2, size/2);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Color based on gender and energy
                    const energy = bird.energy / 100;
                    let r, g, b;
                    
                    if (bird.gender === 'male') {
                        // Blue for males
                        r = Math.floor(50 + 50 * (1 - energy));
                        g = Math.floor(100 + 100 * energy);
                        b = 255;
                    } else {
                        // Pink for females
                        r = 255;
                        g = Math.floor(100 + 100 * energy);
                        b = Math.floor(150 + 100 * energy);
                    }
                    
                    // Bird body with gradient
                    const bodyGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                    bodyGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 1)`);
                    bodyGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.7)`);
                    ctx.fillStyle = bodyGradient;
                    
                    // Draw bird shape
                    ctx.beginPath();
                    ctx.moveTo(size, 0);
                    ctx.lineTo(-size/2, -size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stress indicator
                    if (bird.stress > 0.7) {
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                    
                    // Selected bird highlight
                    if (selectedBird && selectedBird.id === bird.id) {
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, size * 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                    
                    // Generation indicator for newer birds
                    if (bird.generation > 0) {
                        ctx.fillStyle = 'rgba(255,255,255,0.8)';
                        ctx.font = '10px Arial';
                        ctx.fillText(`G${bird.generation}`, x + 10, y - 10);
                    }
                });
            }
            
            // Update and draw particles
            const dt = 1/60; // 60 FPS assumed
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                if (!particle.update(dt)) {
                    particles.splice(i, 1);
                } else {
                    particle.draw(ctx);
                }
            }
            
            // Add particles for stressed birds
            if (gameState.birds) {
                gameState.birds.forEach(bird => {
                    if (bird.stress > 0.8 && Math.random() < 0.05) {
                        addParticles(bird.x * scaleX, bird.y * scaleY, 'stress', 2);
                    }
                    if (bird.energy < 20 && Math.random() < 0.03) {
                        addParticles(bird.x * scaleX, bird.y * scaleY, 'energy', 1);
                    }
                });
            }
        }
        
        function selectBird(bird) {
            selectedBird = bird;
            
            const info = document.getElementById('selected-bird-info');
            info.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>Bird ${bird.id} (${bird.gender === 'male' ? '♂' : '♀'})</strong><br>
                    Generation: ${bird.generation}<br>
                    Energy: ${Math.round(bird.energy)}%<br>
                    Fitness: ${(bird.fitness * 100).toFixed(1)}%
                </div>
                <div class="tree-node ${bird.gender}">
                    <strong>Genetics:</strong><br>
                    Awareness: ${(bird.genetics.hazard_awareness * 100).toFixed(0)}%<br>
                    Efficiency: ${(bird.genetics.energy_efficiency * 100).toFixed(0)}%<br>
                    Cohesion: ${(bird.genetics.flock_cohesion * 100).toFixed(0)}%
                </div>
            `;
            
            // Request family tree
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'get_family_tree',
                    bird_id: bird.id
                }));
            }
        }
        
        function showBirdTooltip(bird, x, y) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                Bird ${bird.id} (${bird.gender === 'male' ? '♂' : '♀'})<br>
                Gen ${bird.generation} | Energy: ${Math.round(bird.energy)}%<br>
                Fitness: ${(bird.fitness * 100).toFixed(1)}%
            `;
            tooltip.style.left = x + 10 + 'px';
            tooltip.style.top = y - 30 + 'px';
            tooltip.classList.add('show');
        }
        
        function startBreeding() {
            if (!ws || !gameState) return;
            
            // Breeding is now automatic, this function is deprecated
        }
        
        function showBreedingResults(data) {
            console.log('showBreedingResults called with data:', data);
            const overlay = document.getElementById('breeding-overlay');
            
            if (!overlay) {
                console.error('Breeding overlay element not found!');
                return;
            }
            
            // Use actual male/female counts from breeding pool
            const males = data.males_breeding || Math.floor((data.survivors || 0) / 2);
            const females = data.females_breeding || Math.ceil((data.survivors || 0) / 2);
            
            document.getElementById('male-survivors').textContent = males;
            document.getElementById('female-survivors').textContent = females;
            document.getElementById('pairs-formed').textContent = data.pairs_formed || 0;
            document.getElementById('offspring-count').textContent = data.offspring_created || 0;
            document.getElementById('survivors-kept').textContent = data.survivors || 0;
            document.getElementById('new-gen').textContent = data.new_generation || 1;
            document.getElementById('total-pop').textContent = data.population_size || 100;
            
            // Force the overlay to be visible
            overlay.style.display = 'block';
            overlay.style.visibility = 'visible';
            overlay.style.opacity = '1';
            overlay.classList.add('show');
            
            console.log('Breeding overlay should now be visible. Style:', {
                display: overlay.style.display,
                visibility: overlay.style.visibility,
                opacity: overlay.style.opacity,
                classes: overlay.className,
                zIndex: window.getComputedStyle(overlay).zIndex
            });
            
            // Don't auto-hide - wait for user to click continue
            // setTimeout(() => {
            //     overlay.classList.remove('show');
            // }, 5000);
        }
        
        function continueGame() {
            const overlay = document.getElementById('breeding-overlay');
            overlay.classList.remove('show');
            overlay.style.display = 'none';
            
            // Advance to next level
            const levelSelect = document.getElementById('level-select');
            const currentIndex = levelSelect.selectedIndex;
            
            // Move to next level if available
            if (currentIndex < levelSelect.options.length - 1) {
                levelSelect.selectedIndex = currentIndex + 1;
            }
            
            // Start the next level with the new population
            startGame();
        }
        
        function setSpeed(speed) {
            if (!ws) return;
            ws.send(JSON.stringify({ type: 'set_speed', speed: speed }));
        }
        
        function savePopulation() {
            if (!gameState) return;
            
            const data = JSON.stringify(gameState, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `population_gen${gameState.generation}.json`;
            a.click();
        }
        
        function loadPopulation() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    const data = JSON.parse(event.target.result);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'load_population',
                            data: data
                        }));
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // Animation loop
        function animate() {
            renderGame();
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>